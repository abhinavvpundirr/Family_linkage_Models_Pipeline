2025-09-03 14:41:26,302 - __main__ - ERROR - Error in main: [Errno 2] No such file or directory: '../training_pipeline/config/config.yaml'
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 45, in main
    config = load_config()
             ^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 16, in load_config
    with open(config_path, 'r') as file:
         ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../training_pipeline/config/config.yaml'
2025-09-03 14:42:14,744 - __main__ - ERROR - Error in main: [Errno 2] No such file or directory: '../config.yaml'
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 45, in main
    config = load_config()
             ^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 16, in load_config
    with open(config_path, 'r') as file:
         ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../config.yaml'
2025-09-03 14:42:33,489 - __main__ - ERROR - Error in main: Test dataset not found: data/test/testing_dataset.csv
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 49, in main
    raise FileNotFoundError(f"Test dataset not found: {test_dataset_path}")
FileNotFoundError: Test dataset not found: data/test/testing_dataset.csv
2025-09-03 14:44:02,303 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:44:02,323 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:44:02,328 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:44:02,331 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:44:02,335 - __main__ - INFO - Normalized column: address
2025-09-03 14:44:02,337 - __main__ - INFO - Normalized column: city
2025-09-03 14:44:02,340 - __main__ - INFO - Normalized column: state
2025-09-03 14:44:02,343 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:44:02,343 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:44:02,345 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:44:02,345 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:44:02,598 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 83, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:47:24,220 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:47:24,243 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:47:24,248 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:47:24,251 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:47:24,255 - __main__ - INFO - Normalized column: address
2025-09-03 14:47:24,258 - __main__ - INFO - Normalized column: city
2025-09-03 14:47:24,260 - __main__ - INFO - Normalized column: state
2025-09-03 14:47:24,264 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:47:24,264 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:47:24,265 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:47:24,265 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:47:24,471 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 83, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:47,356 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:54:47,378 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:54:47,385 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:54:47,388 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:54:47,391 - __main__ - INFO - Normalized column: address
2025-09-03 14:54:47,394 - __main__ - INFO - Normalized column: city
2025-09-03 14:54:47,397 - __main__ - INFO - Normalized column: state
2025-09-03 14:54:47,400 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:54:47,401 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:54:47,402 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:54:47,402 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:54:47,561 - __main__ - INFO - PostgreSQL functions initialized with schema/table support
2025-09-03 14:54:47,686 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 14:54:47,686 - __main__ - INFO - Created database engine for public.records
2025-09-03 14:54:47,697 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 14:54:47,701 - __main__ - ERROR - Error in compare function: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:47,701 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 105, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/../family_linkage_models/prediction.py", line 46, in compare
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:56,077 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:54:56,086 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:54:56,089 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:54:56,091 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:54:56,095 - __main__ - INFO - Normalized column: address
2025-09-03 14:54:56,098 - __main__ - INFO - Normalized column: city
2025-09-03 14:54:56,101 - __main__ - INFO - Normalized column: state
2025-09-03 14:54:56,103 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:54:56,103 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:54:56,104 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:54:56,105 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:54:56,156 - __main__ - INFO - PostgreSQL functions initialized with schema/table support
2025-09-03 14:54:56,238 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 14:54:56,239 - __main__ - INFO - Created database engine for public.records
2025-09-03 14:54:56,246 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 14:54:56,250 - __main__ - ERROR - Error in compare function: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:56,250 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 105, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/../family_linkage_models/prediction.py", line 46, in compare
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 20:11:08,665 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:11:08,678 - __main__ - INFO - Read 2000 records
2025-09-03 20:11:08,678 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:11:08,681 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:11:08,683 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:11:08,687 - __main__ - INFO - Normalized column: address
2025-09-03 20:11:08,690 - __main__ - INFO - Normalized column: city
2025-09-03 20:11:08,692 - __main__ - INFO - Normalized column: state
2025-09-03 20:11:08,695 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:11:08,696 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:11:08,696 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:11:08,696 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:11:08,870 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:11:08,870 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:11:08,878 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:11:08,878 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:11:08,878 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:11:08,887 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:11:08,887 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-03 20:11:08,887 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-03 20:11:08,887 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-03 20:13:54,081 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-03 20:14:22,374 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-03 20:14:22,377 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:14:22,424 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-03 20:14:22,425 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-03 20:14:31,322 - __main__ - INFO - Extracted 1999000 processed record pairs
2025-09-03 20:14:32,228 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:14:39,594 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-03 20:14:42,860 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:16:17,171 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:16:17,188 - __main__ - INFO - Read 2000 records
2025-09-03 20:16:17,188 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:16:17,191 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:16:17,193 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:16:17,197 - __main__ - INFO - Normalized column: address
2025-09-03 20:16:17,200 - __main__ - INFO - Normalized column: city
2025-09-03 20:16:17,202 - __main__ - INFO - Normalized column: state
2025-09-03 20:16:17,204 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:16:17,204 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:16:17,205 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:16:17,205 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:16:17,525 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:16:17,525 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:16:17,535 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:16:17,535 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:16:17,535 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:16:19,604 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:16:19,604 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 20:16:19,604 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 20:16:19,604 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 20:16:20,822 - __main__ - INFO - Merging blocking tables...
2025-09-03 20:16:20,867 - __main__ - INFO - Merged to 5837 blocking entries with 5183 unique blocks
2025-09-03 20:16:20,867 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 20:16:22,126 - __main__ - INFO - Merging comparison results...
2025-09-03 20:16:22,143 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 20:16:22,143 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:16:22,144 - __main__ - INFO - Progress 100%: Generated 934 record pairs
2025-09-03 20:16:22,144 - __main__ - INFO - Comparison complete: 934 record pairs generated
2025-09-03 20:16:22,150 - __main__ - INFO - Extracted 934 processed record pairs
2025-09-03 20:16:22,956 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:16:23,015 - __main__ - INFO - Generated predictions for 934 record pairs
2025-09-03 20:16:23,019 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:32:54,445 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:32:54,466 - __main__ - INFO - Read 2000 records
2025-09-03 20:32:54,466 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:32:54,472 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:32:54,475 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:32:54,480 - __main__ - INFO - Normalized column: address
2025-09-03 20:32:54,483 - __main__ - INFO - Normalized column: city
2025-09-03 20:32:54,485 - __main__ - INFO - Normalized column: state
2025-09-03 20:32:54,487 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:32:54,487 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:32:54,489 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:32:54,489 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:32:54,803 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:32:54,803 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:32:54,823 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:32:54,823 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:32:54,823 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:32:54,836 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:32:54,836 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-03 20:32:54,836 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-03 20:32:54,836 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-03 20:34:40,952 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-03 20:35:13,339 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-03 20:35:13,340 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:35:13,391 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-03 20:35:13,392 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-03 20:35:23,081 - __main__ - INFO - Extracted 1999000 processed record pairs
2025-09-03 20:35:24,037 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:35:31,665 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-03 20:35:35,971 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:36:51,958 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:36:51,980 - __main__ - INFO - Read 2000 records
2025-09-03 20:36:51,980 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:36:51,987 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:36:51,989 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:36:51,993 - __main__ - INFO - Normalized column: address
2025-09-03 20:36:51,996 - __main__ - INFO - Normalized column: city
2025-09-03 20:36:51,998 - __main__ - INFO - Normalized column: state
2025-09-03 20:36:52,003 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:36:52,004 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:36:52,005 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:36:52,005 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:36:52,293 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:36:52,293 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:36:52,303 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:36:52,303 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:36:52,303 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:36:53,971 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:36:53,971 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 20:36:53,971 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 20:36:53,971 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 20:36:55,256 - __main__ - INFO - Merging blocking tables...
2025-09-03 20:36:55,303 - __main__ - INFO - Merged to 5837 blocking entries with 5183 unique blocks
2025-09-03 20:36:55,303 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 20:36:56,579 - __main__ - INFO - Merging comparison results...
2025-09-03 20:36:56,595 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 20:36:56,596 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:36:56,596 - __main__ - INFO - Progress 100%: Generated 934 record pairs
2025-09-03 20:36:56,596 - __main__ - INFO - Comparison complete: 934 record pairs generated
2025-09-03 20:36:56,602 - __main__ - INFO - Extracted 934 processed record pairs
2025-09-03 20:36:57,397 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:36:57,454 - __main__ - INFO - Generated predictions for 934 record pairs
2025-09-03 20:36:57,682 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:27:17,969 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:27:17,993 - __main__ - INFO - Read 2000 records
2025-09-03 21:27:17,993 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:27:18,003 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:27:18,005 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:27:18,009 - __main__ - INFO - Normalized column: address
2025-09-03 21:27:18,012 - __main__ - INFO - Normalized column: city
2025-09-03 21:27:18,015 - __main__ - INFO - Normalized column: state
2025-09-03 21:27:18,016 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:27:18,017 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:27:18,018 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:27:18,018 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:27:18,387 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:27:18,387 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:27:18,410 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:27:18,410 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:27:18,410 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:27:18,427 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:27:18,427 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:27:18,427 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:27:18,427 - __main__ - ERROR - Error in compare: name '_run_parallel_optimized_comparison' is not defined
2025-09-03 21:27:18,428 - __main__ - ERROR - Error in main: name '_run_parallel_optimized_comparison' is not defined
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 125, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 65, in compare
    _run_parallel_optimized_comparison(
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
NameError: name '_run_parallel_optimized_comparison' is not defined
2025-09-03 21:48:37,534 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:48:37,592 - __main__ - INFO - Read 2000 records
2025-09-03 21:48:37,592 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:48:37,602 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:48:37,604 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:48:37,609 - __main__ - INFO - Normalized column: address
2025-09-03 21:48:37,611 - __main__ - INFO - Normalized column: city
2025-09-03 21:48:37,614 - __main__ - INFO - Normalized column: state
2025-09-03 21:48:37,615 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:48:37,615 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:48:37,617 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:48:37,617 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:48:38,216 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:48:38,216 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:48:38,227 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:48:38,228 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:48:38,228 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:48:38,233 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:48:38,233 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:48:38,233 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:48:38,233 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:48:39,559 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:48:39,670 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:48:39,670 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:48:40,997 - __main__ - INFO - Merging comparison results...
2025-09-03 21:48:41,018 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:48:41,018 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:48:41,021 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:48:44,072 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:48:44,072 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-03 21:49:13,280 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:49:13,293 - __main__ - INFO - Read 2000 records
2025-09-03 21:49:13,294 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:49:13,302 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:49:13,304 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:49:13,308 - __main__ - INFO - Normalized column: address
2025-09-03 21:49:13,311 - __main__ - INFO - Normalized column: city
2025-09-03 21:49:13,313 - __main__ - INFO - Normalized column: state
2025-09-03 21:49:13,314 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:49:13,314 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:49:13,315 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:49:13,315 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:49:13,522 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:49:13,522 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:49:13,532 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:49:13,532 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:49:13,532 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:49:13,540 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:49:13,540 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:49:13,540 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:49:13,540 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:49:14,864 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:49:14,934 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:49:14,934 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:49:16,211 - __main__ - INFO - Merging comparison results...
2025-09-03 21:49:16,235 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:49:16,235 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:49:16,238 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:49:17,002 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:49:17,002 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-03 21:49:20,424 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:49:20,432 - __main__ - INFO - Read 2000 records
2025-09-03 21:49:20,432 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:49:20,441 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:49:20,443 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:49:20,447 - __main__ - INFO - Normalized column: address
2025-09-03 21:49:20,450 - __main__ - INFO - Normalized column: city
2025-09-03 21:49:20,452 - __main__ - INFO - Normalized column: state
2025-09-03 21:49:20,453 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:49:20,454 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:49:20,454 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:49:20,455 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:49:20,579 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:49:20,579 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:49:20,586 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:49:20,586 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:49:20,586 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:49:20,593 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:49:20,593 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:49:20,593 - __main__ - INFO - Using optimized blocking strategy (dataset > 1000)
2025-09-03 21:49:20,593 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:49:21,872 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:49:21,945 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:49:21,945 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:49:23,220 - __main__ - INFO - Merging comparison results...
2025-09-03 21:49:23,243 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:49:23,243 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:49:23,245 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:49:23,768 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:49:23,768 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-04 00:31:42,023 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:31:42,023 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:31:42,023 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:31:42,025 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:31:42,041 - __main__ - INFO - Read 2000 records
2025-09-04 00:31:42,041 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:31:42,048 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:31:42,050 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:31:42,054 - __main__ - INFO - Normalized column: address
2025-09-04 00:31:42,057 - __main__ - INFO - Normalized column: city
2025-09-04 00:31:42,059 - __main__ - INFO - Normalized column: state
2025-09-04 00:31:42,065 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:31:42,065 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:31:42,066 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:31:42,066 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:31:42,422 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:31:42,422 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:31:42,433 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:31:42,433 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:31:42,433 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:31:45,154 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:31:45,155 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:31:45,155 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:31:45,155 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:34:33,548 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:34:59,795 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:34:59,797 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:34:59,844 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:34:59,844 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:35:00,079 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:35:00,158 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:35:40,072 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:35:40,073 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:40:41,920 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:40:41,922 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:40:41,922 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:40:41,923 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:40:41,946 - __main__ - INFO - Read 2000 records
2025-09-04 00:40:41,946 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:40:41,956 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:40:41,959 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:40:41,963 - __main__ - INFO - Normalized column: address
2025-09-04 00:40:41,983 - __main__ - INFO - Normalized column: city
2025-09-04 00:40:41,986 - __main__ - INFO - Normalized column: state
2025-09-04 00:40:41,994 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:40:41,994 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:40:41,995 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:40:41,995 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:40:42,323 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:40:42,323 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:40:42,336 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:40:42,336 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:40:42,336 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:40:44,746 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:40:44,747 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:40:44,747 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:40:44,747 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:43:18,322 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:43:55,085 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:43:55,091 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:43:55,138 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:43:55,139 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:43:55,393 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:43:55,482 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:44:31,713 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:44:31,714 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:45:23,925 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:45:23,925 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:45:23,925 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:45:23,926 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:45:23,949 - __main__ - INFO - Read 2000 records
2025-09-04 00:45:23,950 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:45:23,960 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:45:23,962 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:45:23,966 - __main__ - INFO - Normalized column: address
2025-09-04 00:45:23,969 - __main__ - INFO - Normalized column: city
2025-09-04 00:45:23,971 - __main__ - INFO - Normalized column: state
2025-09-04 00:45:23,976 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:45:23,976 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:45:23,978 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:45:23,978 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:45:24,262 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:45:24,262 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:45:24,271 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:45:24,271 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:45:24,271 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:45:27,113 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:45:27,113 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:45:27,113 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:45:27,113 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:48:17,523 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:48:46,022 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:48:46,023 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:48:46,070 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:48:46,071 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:48:46,428 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:48:46,515 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:49:20,565 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:49:20,566 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:49:36,419 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:49:36,419 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:49:36,419 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:49:36,421 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:49:36,437 - __main__ - INFO - Read 2000 records
2025-09-04 00:49:36,438 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:49:36,443 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:49:36,445 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:49:36,449 - __main__ - INFO - Normalized column: address
2025-09-04 00:49:36,452 - __main__ - INFO - Normalized column: city
2025-09-04 00:49:36,455 - __main__ - INFO - Normalized column: state
2025-09-04 00:49:36,456 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:49:36,456 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:49:36,457 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:49:36,457 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:49:36,741 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:49:36,741 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:49:36,750 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:49:36,750 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:49:36,750 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:49:37,970 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:49:37,970 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 00:49:37,970 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 00:49:37,970 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 00:49:40,517 - __main__ - INFO - Merging blocking tables...
2025-09-04 00:49:40,572 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 00:49:40,572 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 00:49:43,175 - __main__ - INFO - Merging comparison results...
2025-09-04 00:49:43,209 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 00:49:43,209 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:49:43,210 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 00:49:43,210 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 00:49:43,398 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:49:43,401 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 00:49:43,471 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 00:49:43,471 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:06:25,779 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:06:25,779 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:06:25,779 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:06:25,781 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:06:25,800 - __main__ - INFO - Read 2000 records
2025-09-04 01:06:25,800 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:06:25,809 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:06:25,811 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:06:25,815 - __main__ - INFO - Normalized column: address
2025-09-04 01:06:25,818 - __main__ - INFO - Normalized column: city
2025-09-04 01:06:25,820 - __main__ - INFO - Normalized column: state
2025-09-04 01:06:25,822 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:06:25,823 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:06:25,824 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:06:25,824 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:06:26,206 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:06:26,206 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:06:26,220 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:06:26,220 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:06:26,220 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:06:29,566 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:06:29,566 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 01:06:29,566 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 01:06:29,566 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 01:09:18,276 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 01:09:45,172 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 01:09:45,174 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:09:45,222 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 01:09:45,222 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 01:09:45,459 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:09:45,544 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 01:10:19,355 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 01:10:19,357 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:11:33,053 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:11:33,053 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:11:33,053 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:11:33,055 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:11:33,077 - __main__ - INFO - Read 2000 records
2025-09-04 01:11:33,078 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:11:33,087 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:11:33,090 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:11:33,094 - __main__ - INFO - Normalized column: address
2025-09-04 01:11:33,096 - __main__ - INFO - Normalized column: city
2025-09-04 01:11:33,099 - __main__ - INFO - Normalized column: state
2025-09-04 01:11:33,104 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:11:33,104 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:11:33,105 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:11:33,105 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:11:33,438 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:11:33,438 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:11:33,448 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:11:33,448 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:11:33,448 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:11:34,315 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:11:34,316 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 01:11:34,316 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 01:11:34,316 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 01:11:35,617 - __main__ - INFO - Merging blocking tables...
2025-09-04 01:11:35,676 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 01:11:35,677 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 01:11:37,204 - __main__ - INFO - Merging comparison results...
2025-09-04 01:11:37,235 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 01:11:37,235 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:11:37,236 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 01:11:37,236 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 01:11:38,063 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:11:38,066 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 01:11:38,140 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 01:11:38,140 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:11:45,621 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:11:45,621 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:11:45,621 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:11:45,623 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:11:45,630 - __main__ - INFO - Read 2000 records
2025-09-04 01:11:45,631 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:11:45,636 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:11:45,639 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:11:45,643 - __main__ - INFO - Normalized column: address
2025-09-04 01:11:45,645 - __main__ - INFO - Normalized column: city
2025-09-04 01:11:45,648 - __main__ - INFO - Normalized column: state
2025-09-04 01:11:45,649 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:11:45,649 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:11:45,650 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:11:45,650 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:11:45,761 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:11:45,762 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:11:45,768 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:11:45,768 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:11:45,768 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:11:45,774 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:11:45,774 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 01:11:45,774 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 01:11:45,774 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 01:14:31,441 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 01:14:58,860 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 01:14:58,861 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:14:58,913 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 01:14:58,913 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 01:14:59,898 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:14:59,978 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 01:15:33,793 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 01:15:33,794 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:17:22,406 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:17:22,406 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:17:22,406 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:17:22,408 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:17:22,431 - __main__ - INFO - Read 2000 records
2025-09-04 01:17:22,431 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:17:22,441 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:17:22,443 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:17:22,447 - __main__ - INFO - Normalized column: address
2025-09-04 01:17:22,450 - __main__ - INFO - Normalized column: city
2025-09-04 01:17:22,453 - __main__ - INFO - Normalized column: state
2025-09-04 01:17:22,458 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:17:22,458 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:17:22,459 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:17:22,459 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:17:22,734 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:17:22,734 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:17:22,745 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:17:22,745 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:17:22,745 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:17:23,227 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:17:23,228 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 01:17:23,228 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 01:17:23,228 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 01:17:24,435 - __main__ - INFO - Merging blocking tables...
2025-09-04 01:17:24,486 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 01:17:24,486 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 01:17:25,844 - __main__ - INFO - Merging comparison results...
2025-09-04 01:17:25,864 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 01:17:25,864 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:17:25,864 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 01:17:25,864 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 01:17:26,640 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:17:26,643 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 01:17:26,713 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 01:17:26,713 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:39:48,927 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:39:48,936 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:39:48,936 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:39:48,937 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:40:47,220 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:40:47,222 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:40:47,241 - __main__ - INFO - Read 2000 records
2025-09-04 02:40:47,242 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:40:47,250 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:40:47,253 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:40:47,256 - __main__ - INFO - Normalized column: address
2025-09-04 02:40:47,259 - __main__ - INFO - Normalized column: city
2025-09-04 02:40:47,261 - __main__ - INFO - Normalized column: state
2025-09-04 02:40:47,263 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:40:47,264 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:40:47,265 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:40:47,265 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:40:47,681 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:40:47,681 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:40:47,695 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:40:47,695 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:40:47,695 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:40:47,715 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:40:47,715 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:40:47,715 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:40:47,715 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:40:49,026 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:40:49,106 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:40:49,106 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:40:50,448 - __main__ - INFO - Merging comparison results...
2025-09-04 02:40:50,472 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:40:50,472 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:40:50,473 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:40:50,473 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:40:51,336 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:40:51,339 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:40:51,409 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:40:51,409 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:41:02,787 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:41:02,787 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:41:02,787 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:41:02,789 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:42:45,978 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:42:45,980 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:42:46,002 - __main__ - INFO - Read 2000 records
2025-09-04 02:42:46,002 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:42:46,012 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:42:46,015 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:42:46,018 - __main__ - INFO - Normalized column: address
2025-09-04 02:42:46,021 - __main__ - INFO - Normalized column: city
2025-09-04 02:42:46,023 - __main__ - INFO - Normalized column: state
2025-09-04 02:42:46,028 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:42:46,028 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:42:46,030 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:42:46,030 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:42:46,215 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:42:46,215 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:42:46,222 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:42:46,222 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:42:46,222 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:42:46,229 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:42:46,229 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:42:46,229 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:42:46,229 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:42:47,504 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:42:47,562 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:42:47,562 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:42:48,801 - __main__ - INFO - Merging comparison results...
2025-09-04 02:42:48,824 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:42:48,824 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:42:48,825 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:42:48,825 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:42:49,600 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:42:49,602 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:42:49,671 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:42:49,671 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:43:04,135 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:43:04,135 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:43:04,135 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:43:04,136 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:48:43,099 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:48:43,101 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:50:31,087 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:50:31,088 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:50:43,630 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:50:43,632 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:51:42,453 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:51:42,455 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:51:42,478 - __main__ - INFO - Read 2000 records
2025-09-04 02:51:42,478 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:51:42,487 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:51:42,489 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:51:42,493 - __main__ - INFO - Normalized column: address
2025-09-04 02:51:42,496 - __main__ - INFO - Normalized column: city
2025-09-04 02:51:42,499 - __main__ - INFO - Normalized column: state
2025-09-04 02:51:42,504 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:51:42,504 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:51:42,505 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:51:42,505 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:51:42,819 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:51:42,819 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:51:42,828 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:51:42,828 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:51:42,828 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:51:42,839 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:51:42,840 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:51:42,840 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:51:42,840 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:51:44,287 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:51:44,341 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:51:44,341 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:51:45,624 - __main__ - INFO - Merging comparison results...
2025-09-04 02:51:45,653 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:51:45,653 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:51:45,653 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:51:45,653 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:51:46,492 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:51:46,495 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:51:46,564 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:51:46,564 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:52:52,562 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:52:52,562 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:52:52,562 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:52:52,564 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:20,843 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:53:20,845 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:44,224 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:53:44,225 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:53:44,247 - __main__ - INFO - Read 2000 records
2025-09-04 02:53:44,248 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:53:44,256 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:53:44,258 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:53:44,262 - __main__ - INFO - Normalized column: address
2025-09-04 02:53:44,264 - __main__ - INFO - Normalized column: city
2025-09-04 02:53:44,267 - __main__ - INFO - Normalized column: state
2025-09-04 02:53:44,272 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:53:44,272 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:53:44,273 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:53:44,273 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:53:44,467 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:53:44,467 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:53:44,482 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:53:44,482 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:53:44,482 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:53:44,497 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:53:44,497 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:53:44,497 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:53:44,497 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:53:45,900 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:53:45,957 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:53:45,957 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:53:47,254 - __main__ - INFO - Merging comparison results...
2025-09-04 02:53:47,283 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:53:47,283 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:53:47,284 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:53:47,284 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:53:48,084 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:48,087 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:53:48,099 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:53:48,099 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:54:15,328 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:54:15,330 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:54:15,351 - __main__ - INFO - Read 2000 records
2025-09-04 02:54:15,352 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:54:15,361 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:54:15,363 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:54:15,367 - __main__ - INFO - Normalized column: address
2025-09-04 02:54:15,370 - __main__ - INFO - Normalized column: city
2025-09-04 02:54:15,372 - __main__ - INFO - Normalized column: state
2025-09-04 02:54:15,377 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:54:15,377 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:54:15,379 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:54:15,379 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:54:15,559 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:54:15,559 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:54:15,568 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:54:15,568 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:54:15,568 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:54:15,575 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:54:15,575 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:54:15,575 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:54:15,575 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:54:16,907 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:54:16,963 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:54:16,963 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:54:18,240 - __main__ - INFO - Merging comparison results...
2025-09-04 02:54:18,260 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:54:18,260 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:54:18,261 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:54:18,261 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:54:19,008 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:54:19,010 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:54:19,023 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:54:19,023 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:56:01,363 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:56:01,365 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:56:01,386 - __main__ - INFO - Read 2000 records
2025-09-04 02:56:01,387 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:56:01,396 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:56:01,399 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:56:01,403 - __main__ - INFO - Normalized column: address
2025-09-04 02:56:01,405 - __main__ - INFO - Normalized column: city
2025-09-04 02:56:01,408 - __main__ - INFO - Normalized column: state
2025-09-04 02:56:01,413 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:56:01,414 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:56:01,415 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:56:01,415 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:56:01,626 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:56:01,626 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:56:01,635 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:56:01,635 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:56:01,635 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:56:01,651 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:56:01,651 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:56:01,651 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:56:01,651 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:56:02,999 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:56:03,050 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:56:03,050 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:56:04,329 - __main__ - INFO - Merging comparison results...
2025-09-04 02:56:04,348 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:56:04,348 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:56:04,349 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:56:04,349 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:56:05,095 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:56:05,098 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:56:05,110 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:56:05,110 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:11:38,773 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:11:38,775 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:11:38,796 - __main__ - INFO - Read 2000 records
2025-09-04 03:11:38,797 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:11:38,806 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:11:38,809 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:11:38,812 - __main__ - INFO - Normalized column: address
2025-09-04 03:11:38,815 - __main__ - INFO - Normalized column: city
2025-09-04 03:11:38,818 - __main__ - INFO - Normalized column: state
2025-09-04 03:11:38,822 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:11:38,823 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:11:38,824 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:11:38,824 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:11:39,162 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:11:39,162 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:11:39,172 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:11:39,172 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:11:39,172 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:11:39,186 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:11:39,186 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 03:11:39,186 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 03:11:39,186 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 03:11:40,422 - __main__ - INFO - Merging blocking tables...
2025-09-04 03:11:40,484 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 03:11:40,484 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 03:11:41,743 - __main__ - INFO - Merging comparison results...
2025-09-04 03:11:41,764 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 03:11:41,765 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:11:41,765 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 03:11:41,765 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 03:11:42,570 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:11:42,573 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 03:11:42,585 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:11:42,585 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:14:13,781 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:14:13,782 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:14:13,807 - __main__ - INFO - Read 2000 records
2025-09-04 03:14:13,807 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:14:13,816 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:14:13,819 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:14:13,822 - __main__ - INFO - Normalized column: address
2025-09-04 03:14:13,825 - __main__ - INFO - Normalized column: city
2025-09-04 03:14:13,827 - __main__ - INFO - Normalized column: state
2025-09-04 03:14:13,833 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:14:13,833 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:14:13,834 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:14:13,834 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:14:14,032 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:14:14,032 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:14:14,041 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:14:14,041 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:14:14,041 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:14:14,058 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:14:14,058 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 03:14:14,058 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 03:14:14,058 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 03:14:15,336 - __main__ - INFO - Merging blocking tables...
2025-09-04 03:14:15,388 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 03:14:15,388 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 03:14:16,697 - __main__ - INFO - Merging comparison results...
2025-09-04 03:14:16,714 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 03:14:16,714 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:14:16,715 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 03:14:16,715 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 03:14:17,521 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:14:17,523 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 03:14:17,592 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 03:14:17,592 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-04 03:32:21,071 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-04 03:32:21,077 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 03:32:21,077 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:32:21,078 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:32:21,099 - __main__ - INFO - Read 2000 records
2025-09-04 03:32:21,100 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:32:21,108 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:32:21,111 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:32:21,115 - __main__ - INFO - Normalized column: address
2025-09-04 03:32:21,117 - __main__ - INFO - Normalized column: city
2025-09-04 03:32:21,120 - __main__ - INFO - Normalized column: state
2025-09-04 03:32:21,124 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:32:21,125 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:32:21,126 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:32:21,126 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:32:21,314 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:32:21,314 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:32:21,322 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:32:21,322 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:32:21,322 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:32:21,331 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:32:21,331 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 03:32:21,331 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 03:32:21,331 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 03:32:22,595 - __main__ - INFO - Merging blocking tables...
2025-09-04 03:32:22,650 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 03:32:22,651 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 03:32:23,924 - __main__ - INFO - Merging comparison results...
2025-09-04 03:32:23,945 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 03:32:23,945 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:32:23,945 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 03:32:23,945 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 03:32:24,696 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:32:24,699 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 03:32:24,768 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 03:32:24,768 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-04 03:32:34,184 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-04 03:32:34,184 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 03:32:34,184 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:32:34,185 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:32:34,193 - __main__ - INFO - Read 2000 records
2025-09-04 03:32:34,193 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:32:34,198 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:32:34,201 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:32:34,205 - __main__ - INFO - Normalized column: address
2025-09-04 03:32:34,207 - __main__ - INFO - Normalized column: city
2025-09-04 03:32:34,210 - __main__ - INFO - Normalized column: state
2025-09-04 03:32:34,211 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:32:34,211 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:32:34,212 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:32:34,212 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:32:34,329 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:32:34,329 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:32:34,337 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:32:34,337 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:32:34,337 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:32:34,345 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:32:34,345 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 03:32:34,345 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 03:32:34,345 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 03:34:07,612 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 03:34:44,447 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 03:34:44,449 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:34:44,501 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 03:34:44,501 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 03:34:45,450 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:34:45,538 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 03:35:23,619 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 03:35:23,620 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-04 04:13:48,072 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-04 04:13:48,072 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 04:13:48,072 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 04:13:48,074 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 04:13:48,095 - __main__ - INFO - Read 2000 records
2025-09-04 04:13:48,096 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 04:13:48,105 - __main__ - INFO - Normalized column: last_name
2025-09-04 04:13:48,107 - __main__ - INFO - Normalized column: middle_name
2025-09-04 04:13:48,111 - __main__ - INFO - Normalized column: address
2025-09-04 04:13:48,114 - __main__ - INFO - Normalized column: city
2025-09-04 04:13:48,117 - __main__ - INFO - Normalized column: state
2025-09-04 04:13:48,122 - __main__ - INFO - Converted DOB to datetime
2025-09-04 04:13:48,122 - __main__ - INFO - Cleaned SSN column
2025-09-04 04:13:48,123 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 04:13:48,123 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 04:13:48,430 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 04:13:48,430 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 04:13:48,439 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 04:13:48,439 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 04:13:48,439 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 04:13:48,445 - __main__ - INFO - Cleaned up existing tables
2025-09-04 04:13:48,445 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 04:13:48,445 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 04:13:48,445 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 04:15:31,015 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 04:16:09,754 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 04:16:09,756 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 04:16:09,806 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 04:16:09,806 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 04:16:12,032 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 04:16:12,136 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 04:16:57,980 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 04:16:57,984 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-04 04:23:38,010 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-04 04:23:38,010 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 04:23:38,010 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 04:23:38,012 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 04:23:38,032 - __main__ - INFO - Read 2000 records
2025-09-04 04:23:38,032 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 04:23:38,042 - __main__ - INFO - Normalized column: last_name
2025-09-04 04:23:38,044 - __main__ - INFO - Normalized column: middle_name
2025-09-04 04:23:38,048 - __main__ - INFO - Normalized column: address
2025-09-04 04:23:38,050 - __main__ - INFO - Normalized column: city
2025-09-04 04:23:38,053 - __main__ - INFO - Normalized column: state
2025-09-04 04:23:38,058 - __main__ - INFO - Converted DOB to datetime
2025-09-04 04:23:38,058 - __main__ - INFO - Cleaned SSN column
2025-09-04 04:23:38,059 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 04:23:38,059 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 04:23:38,484 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 04:23:38,484 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 04:23:38,496 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 04:23:38,496 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 04:23:38,496 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 04:23:40,965 - __main__ - INFO - Cleaned up existing tables
2025-09-04 04:23:40,965 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 04:23:40,965 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 04:23:40,965 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 04:25:14,998 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 04:25:49,235 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 04:25:49,239 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 04:25:49,287 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 04:25:49,287 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 04:25:50,174 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 04:25:50,263 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 04:26:33,037 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 04:26:33,044 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 13:42:06,517 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 13:42:06,525 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 13:42:06,525 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 13:42:06,527 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 13:42:06,551 - __main__ - INFO - Read 2000 records
2025-09-09 13:42:06,551 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 13:42:06,561 - __main__ - INFO - Normalized column: last_name
2025-09-09 13:42:06,563 - __main__ - INFO - Normalized column: middle_name
2025-09-09 13:42:06,567 - __main__ - INFO - Normalized column: address
2025-09-09 13:42:06,570 - __main__ - INFO - Normalized column: city
2025-09-09 13:42:06,572 - __main__ - INFO - Normalized column: state
2025-09-09 13:42:06,577 - __main__ - INFO - Converted DOB to datetime
2025-09-09 13:42:06,578 - __main__ - INFO - Cleaned SSN column
2025-09-09 13:42:06,579 - __main__ - INFO - Removed 0 placeholder records
2025-09-09 13:42:06,579 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 13:42:07,203 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 13:42:07,203 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 13:42:07,218 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 13:42:07,218 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 13:42:07,218 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 13:42:09,054 - __main__ - INFO - Cleaned up existing tables
2025-09-09 13:42:09,054 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 13:42:09,054 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 13:42:09,054 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 13:43:43,869 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 13:44:28,606 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 13:44:28,608 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 13:44:28,656 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 13:44:28,656 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 13:44:30,325 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 13:44:30,406 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 13:45:18,638 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 13:45:18,643 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 14:04:32,253 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 14:04:32,253 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 14:04:32,253 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 14:04:32,255 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 14:04:32,276 - __main__ - INFO - Read 2000 records
2025-09-09 14:04:32,276 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 14:04:32,283 - __main__ - INFO - Normalized column: last_name
2025-09-09 14:04:32,286 - __main__ - INFO - Normalized column: middle_name
2025-09-09 14:04:32,290 - __main__ - INFO - Normalized column: address
2025-09-09 14:04:32,292 - __main__ - INFO - Normalized column: city
2025-09-09 14:04:32,295 - __main__ - INFO - Normalized column: state
2025-09-09 14:04:32,300 - __main__ - INFO - Converted DOB to datetime
2025-09-09 14:04:32,300 - __main__ - INFO - Cleaned SSN column
2025-09-09 14:04:32,301 - __main__ - INFO - Removed 0 placeholder records
2025-09-09 14:04:32,301 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 14:04:32,479 - __main__ - ERROR - Error in main: (psycopg2.errors.SyntaxError) unterminated dollar-quoted string at or near "$$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %I.block_sizes bs
                       WHERE bs.block_size <= %s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        -- FIXED: Cast text dob to date for AGE calculation
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}'' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %I.record_blocks rb
                    JOIN %s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name, job_schema, full_table_name
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table % with % comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %s AS
       WITH age_data AS (
           SELECT 
               r.*,
               -- FIXED: Cast text dob to date for AGE calculation
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           -- FIXED: Use text-compatible age_difference with casting
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table % with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS (NO CHANGES NEEDED)
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''record_blocks_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.record_blocks SELECT * FROM %I.%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final record_blocks table has % records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created % unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''processed_records_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.processed_records SELECT * FROM %I.%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final processed_records table has % record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Process positive record pairs (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of % record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           -- FIXED: Cast text dob to date for AGE calculation
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       -- FIXED: Use text-compatible age_difference with casting
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %', clock_timestamp() - start_time;
END;
$ LANGUAGE plpgsql;"
LINE 648: ) RETURNS void AS $$
                            ^

[SQL: -- ============================================================================
-- FAMILY LINKAGE POSTGRESQL FUNCTIONS (CURL COMPATIBLE - TEXT COLUMNS)
-- All functions updated to handle TEXT columns with proper casting
-- ============================================================================

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Edit distance function (no changes needed)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Age difference function (no changes needed - already handles NULL)
CREATE OR REPLACE FUNCTION age_difference(dob1 date, dob2 date)
RETURNS double precision AS $$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$$ LANGUAGE plpgsql;

-- Soundex function (no changes needed)
CREATE OR REPLACE FUNCTION soundex(input_string text)
RETURNS text AS $$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL OR input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- BLOCKING FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Create blocking keys (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 100000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                -- FIXED: Cast text dob to date for EXTRACT
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    -- Create block_sizes table
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Create blocking keys for parallel workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := quote_ident(job_schema) || '.record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := quote_ident(job_schema) || '.record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    EXECUTE format('SELECT COUNT(*) FROM %%s WHERE ($1 IS NULL OR id >= $1) AND ($2 IS NULL OR id <= $2)', 
                   full_table_name) 
    INTO total_records USING gid_start, gid_end;
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                -- FIXED: Cast text dob to date for EXTRACT
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name, full_table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%s(block_key)', 
                   'idx_' || replace(table_name, '.', '_') || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%s(id)', 
                   'idx_' || replace(table_name, '.', '_') || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMPARISON FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Optimized record comparison (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block with TEXT to DATE casting
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    -- FIXED: Cast text dob to date for AGE calculation
                    CASE 
                        WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                        ELSE NULL 
                    END as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                -- FIXED: Use text-compatible age_difference with casting
                CASE 
                    WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                         r1_dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                    ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                END,
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Exhaustive record comparison (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Create exhaustive comparisons with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                -- FIXED: Cast text dob to date for AGE calculation
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                    ELSE NULL 
                END as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            -- FIXED: Use text-compatible age_difference with casting
            CASE 
                WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                     r1.dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
            END,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PARALLEL PROCESSING FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Parallel optimized comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        -- FIXED: Cast text dob to date for AGE calculation
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}'' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %%I.record_blocks rb
                    JOIN %%s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name, job_schema, full_table_name
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %%s AS
       WITH age_data AS (
           SELECT 
               r.*,
               -- FIXED: Cast text dob to date for AGE calculation
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %%s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           -- FIXED: Use text-compatible age_difference with casting
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table %% with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS (NO CHANGES NEEDED)
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''record_blocks_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.record_blocks SELECT * FROM %%I.%%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %%I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %%I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %%I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %%I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %%I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %%I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %%I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''processed_records_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.processed_records SELECT * FROM %%I.%%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final processed_records table has %% record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Process positive record pairs (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           -- FIXED: Cast text dob to date for AGE calculation
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       -- FIXED: Use text-compatible age_difference with casting
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$ LANGUAGE plpgsql;]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.SyntaxError: unterminated dollar-quoted string at or near "$$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %I.block_sizes bs
                       WHERE bs.block_size <= %s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        -- FIXED: Cast text dob to date for AGE calculation
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}'' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %I.record_blocks rb
                    JOIN %s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name, job_schema, full_table_name
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table % with % comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %s AS
       WITH age_data AS (
           SELECT 
               r.*,
               -- FIXED: Cast text dob to date for AGE calculation
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           -- FIXED: Use text-compatible age_difference with casting
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table % with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS (NO CHANGES NEEDED)
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''record_blocks_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.record_blocks SELECT * FROM %I.%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final record_blocks table has % records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created % unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''processed_records_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.processed_records SELECT * FROM %I.%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final processed_records table has % record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Process positive record pairs (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of % record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           -- FIXED: Cast text dob to date for AGE calculation
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       -- FIXED: Use text-compatible age_difference with casting
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %', clock_timestamp() - start_time;
END;
$ LANGUAGE plpgsql;"
LINE 648: ) RETURNS void AS $$
                            ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 131, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.SyntaxError) unterminated dollar-quoted string at or near "$$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %I.block_sizes bs
                       WHERE bs.block_size <= %s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        -- FIXED: Cast text dob to date for AGE calculation
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}'' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %I.record_blocks rb
                    JOIN %s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name, job_schema, full_table_name
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table % with % comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %s AS
       WITH age_data AS (
           SELECT 
               r.*,
               -- FIXED: Cast text dob to date for AGE calculation
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           -- FIXED: Use text-compatible age_difference with casting
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table % with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS (NO CHANGES NEEDED)
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''record_blocks_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.record_blocks SELECT * FROM %I.%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final record_blocks table has % records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created % unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %L 
                      AND tablename LIKE ''processed_records_worker_%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %I.processed_records SELECT * FROM %I.%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %I.%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged % records from %', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged % worker tables. Final processed_records table has % record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Process positive record pairs (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of % record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           -- FIXED: Cast text dob to date for AGE calculation
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       -- FIXED: Use text-compatible age_difference with casting
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %', clock_timestamp() - start_time;
END;
$ LANGUAGE plpgsql;"
LINE 648: ) RETURNS void AS $$
                            ^

[SQL: -- ============================================================================
-- FAMILY LINKAGE POSTGRESQL FUNCTIONS (CURL COMPATIBLE - TEXT COLUMNS)
-- All functions updated to handle TEXT columns with proper casting
-- ============================================================================

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Edit distance function (no changes needed)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Age difference function (no changes needed - already handles NULL)
CREATE OR REPLACE FUNCTION age_difference(dob1 date, dob2 date)
RETURNS double precision AS $$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$$ LANGUAGE plpgsql;

-- Soundex function (no changes needed)
CREATE OR REPLACE FUNCTION soundex(input_string text)
RETURNS text AS $$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL OR input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- BLOCKING FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Create blocking keys (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 100000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                -- FIXED: Cast text dob to date for EXTRACT
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    -- Create block_sizes table
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Create blocking keys for parallel workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := quote_ident(job_schema) || '.record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := quote_ident(job_schema) || '.record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    EXECUTE format('SELECT COUNT(*) FROM %%s WHERE ($1 IS NULL OR id >= $1) AND ($2 IS NULL OR id <= $2)', 
                   full_table_name) 
    INTO total_records USING gid_start, gid_end;
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                -- FIXED: Cast text dob to date for EXTRACT
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name, full_table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%s(block_key)', 
                   'idx_' || replace(table_name, '.', '_') || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%s(id)', 
                   'idx_' || replace(table_name, '.', '_') || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMPARISON FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Optimized record comparison (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block with TEXT to DATE casting
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    -- FIXED: Cast text dob to date for AGE calculation
                    CASE 
                        WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                        ELSE NULL 
                    END as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                -- FIXED: Use text-compatible age_difference with casting
                CASE 
                    WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                         r1_dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                    ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                END,
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Exhaustive record comparison (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Create exhaustive comparisons with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                -- FIXED: Cast text dob to date for AGE calculation
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                    ELSE NULL 
                END as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            -- FIXED: Use text-compatible age_difference with casting
            CASE 
                WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                     r1.dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
            END,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PARALLEL PROCESSING FUNCTIONS (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Parallel optimized comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        -- FIXED: Cast text dob to date for AGE calculation
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}'' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %%I.record_blocks rb
                    JOIN %%s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2} AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name, job_schema, full_table_name
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %%s AS
       WITH age_data AS (
           SELECT 
               r.*,
               -- FIXED: Cast text dob to date for AGE calculation
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %%s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           -- FIXED: Use text-compatible age_difference with casting
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table %% with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS (NO CHANGES NEEDED)
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''record_blocks_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.record_blocks SELECT * FROM %%I.%%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %%I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %%I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %%I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %%I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %%I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %%I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %%I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''processed_records_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.processed_records SELECT * FROM %%I.%%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final processed_records table has %% record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE (UPDATED FOR TEXT COLUMNS)
-- ============================================================================

-- Process positive record pairs (updated for TEXT dob column)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           -- FIXED: Cast text dob to date for AGE calculation
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       -- FIXED: Use text-compatible age_difference with casting
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$ LANGUAGE plpgsql;]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-09 14:10:04,282 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 14:10:04,284 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 14:10:04,305 - __main__ - INFO - Read 2000 records
2025-09-09 14:10:04,305 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 14:10:04,314 - __main__ - INFO - Normalized column: last_name
2025-09-09 14:10:04,317 - __main__ - INFO - Normalized column: middle_name
2025-09-09 14:10:04,321 - __main__ - INFO - Normalized column: address
2025-09-09 14:10:04,323 - __main__ - INFO - Normalized column: city
2025-09-09 14:10:04,326 - __main__ - INFO - Normalized column: state
2025-09-09 14:10:04,329 - __main__ - INFO - Converted DOB to datetime
2025-09-09 14:10:04,330 - __main__ - INFO - Cleaned SSN column
2025-09-09 14:10:04,331 - __main__ - INFO - Removed 0 placeholder records
2025-09-09 14:10:04,331 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 14:10:04,541 - __main__ - ERROR - Error in main: (psycopg2.errors.SyntaxError) syntax error at or near "THEN"
LINE 715: ...LL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                                                                    ^

[SQL: -- ============================================================================
-- FAMILY LINKAGE POSTGRESQL FUNCTIONS (CURL COMPATIBLE - TEXT COLUMNS)
-- All functions updated to handle TEXT columns with proper casting - COMPLETE FILE
-- ============================================================================

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Edit distance function
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Age difference function
CREATE OR REPLACE FUNCTION age_difference(dob1 date, dob2 date)
RETURNS double precision AS $$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$$ LANGUAGE plpgsql;

-- Soundex function
CREATE OR REPLACE FUNCTION soundex(input_string text)
RETURNS text AS $$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL OR input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- BLOCKING FUNCTIONS
-- ============================================================================

-- Create blocking keys (main function)
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 100000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    -- Create block_sizes table
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Create blocking keys for parallel workers
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := quote_ident(job_schema) || '.record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := quote_ident(job_schema) || '.record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    EXECUTE format('SELECT COUNT(*) FROM %%s WHERE ($1 IS NULL OR id >= $1) AND ($2 IS NULL OR id <= $2)', 
                   full_table_name) 
    INTO total_records USING gid_start, gid_end;
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name, full_table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%s(block_key)', 
                   'idx_' || replace(table_name, '.', '_') || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%s(id)', 
                   'idx_' || replace(table_name, '.', '_') || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMPARISON FUNCTIONS
-- ============================================================================

-- Optimized record comparison
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block with TEXT to DATE casting
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    CASE 
                        WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                        ELSE NULL 
                    END as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                CASE 
                    WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                         r1_dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                    ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                END,
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Exhaustive record comparison
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Create exhaustive comparisons with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                    ELSE NULL 
                END as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            CASE 
                WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                     r1.dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
            END,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PARALLEL PROCESSING FUNCTIONS
-- ============================================================================

-- Parallel optimized comparison for workers
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %%I.record_blocks rb
                    JOIN %%s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           ', temp_table_name, job_schema, full_table_name) 
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %%s AS
       WITH age_data AS (
           SELECT 
               r.*,
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %%s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table %% with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''record_blocks_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.record_blocks SELECT * FROM %%I.%%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %%I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %%I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %%I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %%I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %%I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %%I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %%I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''processed_records_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.processed_records SELECT * FROM %%I.%%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final processed_records table has %% record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE
-- ============================================================================

-- Process positive record pairs (only used in training)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.SyntaxError: syntax error at or near "THEN"
LINE 715: ...LL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                                                                    ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 131, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.SyntaxError) syntax error at or near "THEN"
LINE 715: ...LL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                                                                    ^

[SQL: -- ============================================================================
-- FAMILY LINKAGE POSTGRESQL FUNCTIONS (CURL COMPATIBLE - TEXT COLUMNS)
-- All functions updated to handle TEXT columns with proper casting - COMPLETE FILE
-- ============================================================================

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Edit distance function
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Age difference function
CREATE OR REPLACE FUNCTION age_difference(dob1 date, dob2 date)
RETURNS double precision AS $$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$$ LANGUAGE plpgsql;

-- Soundex function
CREATE OR REPLACE FUNCTION soundex(input_string text)
RETURNS text AS $$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL OR input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- BLOCKING FUNCTIONS
-- ============================================================================

-- Create blocking keys (main function)
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 100000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    -- Create block_sizes table
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Create blocking keys for parallel workers
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    full_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := quote_ident(job_schema) || '.record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := quote_ident(job_schema) || '.record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    EXECUTE format('SELECT COUNT(*) FROM %%s WHERE ($1 IS NULL OR id >= $1) AND ($2 IS NULL OR id <= $2)', 
                   full_table_name) 
    INTO total_records USING gid_start, gid_end;
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Create blocking keys with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM r.dob::DATE)
                    ELSE NULL 
                END as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name, full_table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%s(block_key)', 
                   'idx_' || replace(table_name, '.', '_') || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%s(id)', 
                   'idx_' || replace(table_name, '.', '_') || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMPARISON FUNCTIONS
-- ============================================================================

-- Optimized record comparison
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block with TEXT to DATE casting
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    CASE 
                        WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                        ELSE NULL 
                    END as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                CASE 
                    WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                         r1_dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                    ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                END,
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Exhaustive record comparison
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create processed_records table
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', processed_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', processed_table_name);
    
    -- Create exhaustive comparisons with TEXT to DATE casting
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                CASE 
                    WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}$'' THEN 
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                    ELSE NULL 
                END as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            CASE 
                WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                     r1.dob !~ ''^\d{4}-\d{2}-\d{2}$'' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}$'' THEN 100
                ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
            END,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PARALLEL PROCESSING FUNCTIONS
-- ============================================================================

-- Parallel optimized comparison for workers
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT '',
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
    full_table_name text;
BEGIN
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%s (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s 
                         AND bs.block_size > 3
                         AND bs.block_key BETWEEN $1 AND $2
                       ORDER BY bs.block_size', job_schema, max_block_size)
        USING block_key_start, block_key_end
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%s (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        CASE 
                            WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                            ELSE NULL 
                        END as age_years
                    FROM %%I.record_blocks rb
                    JOIN %%s r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN 
                            (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                             r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                             age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   CASE 
                       WHEN r1_dob IS NULL OR r1_dob = '''' OR r2_dob IS NULL OR r2_dob = '''' OR 
                            r1_dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2_dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
                       ELSE age_difference(r1_dob::DATE, r2_dob::DATE)
                   END,
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = ''M'' THEN 0
                       WHEN r1_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = ''M'' THEN 0
                       WHEN r2_sex = ''F'' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN 
                        (r1_dob IS NOT NULL AND r1_dob != '''' AND r1_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                         r2_dob IS NOT NULL AND r2_dob != '''' AND r2_dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                         age_difference(r1_dob::DATE, r2_dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           ', temp_table_name, job_schema, full_table_name) 
           USING block_key_val, window_start, window_end, similarity_threshold;
           
           GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
           total_comparisons := total_comparisons + curr_window_matches;
           
           window_start := window_start + window_size - overlap;
       END LOOP;
   END LOOP;
   
   RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$ LANGUAGE plpgsql;

-- Parallel exhaustive comparison for workers
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
   gid_start text,
   gid_end text,
   table_suffix text DEFAULT '',
   job_schema text DEFAULT 'public',
   records_table text DEFAULT 'records'
) RETURNS void AS $
DECLARE
   temp_table_name text;
   full_table_name text;
BEGIN
   -- Build table names
   full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
   
   IF table_suffix IS NULL OR table_suffix = '' THEN
       temp_table_name := quote_ident(job_schema) || '.processed_records_temp';
   ELSE
       table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
       temp_table_name := quote_ident(job_schema) || '.processed_records_worker_' || table_suffix;
   END IF;
   
   EXECUTE format('DROP TABLE IF EXISTS %%s CASCADE', temp_table_name);
   
   EXECUTE format('
       CREATE UNLOGGED TABLE %%s AS
       WITH age_data AS (
           SELECT 
               r.*,
               CASE 
                   WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                       EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
                   ELSE NULL 
               END as age_years
           FROM %%s r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN 
                    (r1.dob IS NOT NULL AND r1.dob != '''' AND r1.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     r2.dob IS NOT NULL AND r2.dob != '''' AND r2.dob ~ ''^\d{4}-\d{2}-\d{2}' AND
                     age_difference(r1.dob::DATE, r2.dob::DATE) BETWEEN -0.55 AND 0.55) THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           CASE 
               WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                    r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
               ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
           END as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = ''M'' THEN 0
               WHEN r1.sex = ''F'' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = ''M'' THEN 0
               WHEN r2.sex = ''F'' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   ', temp_table_name, full_table_name) 
   USING gid_start, gid_end;
   
   RAISE NOTICE 'Created worker table %% with exhaustive comparison', temp_table_name;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- MERGE FUNCTIONS
-- ============================================================================

-- Merge blocking tables from workers
CREATE OR REPLACE FUNCTION merge_blocking_tables(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
   EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
       id TEXT,
       block_key TEXT,
       sort_key TEXT
   )', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''record_blocks_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.record_blocks SELECT * FROM %%I.%%I', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_block_key ON %%I.record_blocks(block_key)', job_schema);
   EXECUTE format('CREATE INDEX IF NOT EXISTS idx_gid_blocks ON %%I.record_blocks(id)', job_schema);
   
   EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
   EXECUTE format('CREATE TABLE %%I.block_sizes AS
                  SELECT block_key, COUNT(*) AS block_size
                  FROM %%I.record_blocks
                  GROUP BY block_key', job_schema, job_schema, job_schema);
   
   EXECUTE format('CREATE INDEX idx_block_sizes ON %%I.block_sizes(block_key)', job_schema);
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.record_blocks', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes', job_schema) INTO total_records;
   RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$ LANGUAGE plpgsql;

-- Merge processed records from workers
CREATE OR REPLACE FUNCTION merge_processed_records(job_schema text DEFAULT 'public')
RETURNS void AS $
DECLARE
   table_record record;
   total_records bigint := 0;
   merged_count integer := 0;
BEGIN
   -- Create processed_records if it doesn't exist
   EXECUTE format('CREATE TABLE IF NOT EXISTS %%I.processed_records (
       from_id TEXT,
       to_id TEXT,
       similarity_score FLOAT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   )', job_schema);
   
   -- If table was just created, it's empty. Otherwise truncate it.
   EXECUTE format('TRUNCATE %%I.processed_records', job_schema);
   
   FOR table_record IN 
       EXECUTE format('SELECT tablename 
                      FROM pg_tables 
                      WHERE schemaname = %%L 
                      AND tablename LIKE ''processed_records_worker_%%%%''',
                      job_schema)
   LOOP
       EXECUTE format('INSERT INTO %%I.processed_records SELECT * FROM %%I.%%I ON CONFLICT (from_id, to_id) DO NOTHING', 
                     job_schema, job_schema, table_record.tablename);
       
       EXECUTE format('SELECT COUNT(*) FROM %%I.%%I', job_schema, table_record.tablename) 
       INTO total_records;
       RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
       
       EXECUTE format('DROP TABLE IF EXISTS %%I.%%I CASCADE', job_schema, table_record.tablename);
       
       merged_count := merged_count + 1;
   END LOOP;
   
   EXECUTE format('SELECT COUNT(*) FROM %%I.processed_records', job_schema) INTO total_records;
   RAISE NOTICE 'Merged %% worker tables. Final processed_records table has %% record pairs', 
       merged_count, total_records;
END;
$ LANGUAGE plpgsql;

-- ============================================================================
-- SPECIAL FUNCTIONS FOR TRAINING PIPELINE
-- ============================================================================

-- Process positive record pairs (only used in training)
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $
DECLARE
   total_pairs integer;
   start_time timestamp;
BEGIN
   start_time := clock_timestamp();
   
   SELECT COUNT(*) INTO total_pairs FROM labels;
   
   RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
   
   DROP TABLE IF EXISTS processed_positive_records;
   CREATE UNLOGGED TABLE processed_positive_records (
       from_id TEXT,
       to_id TEXT,
       edit_dist_ln FLOAT,
       edit_dist_phone_num FLOAT,
       edit_dist_mn FLOAT,
       edit_dist_zip FLOAT,
       edit_dist_city FLOAT,
       age_diff FLOAT,
       sex_diff INTEGER,
       ssn_match INTEGER,
       state_match INTEGER,
       edit_dist_mail_address FLOAT,
       record1_sex INTEGER,
       record2_sex INTEGER,
       record1_agecategory INTEGER,
       record2_agecategory INTEGER,
       PRIMARY KEY (from_id, to_id)
   );
   
   -- Process positive pairs from labels with TEXT to DATE casting
   INSERT INTO processed_positive_records
   WITH age_data AS (
       SELECT 
           r.*,
           CASE 
               WHEN r.dob IS NOT NULL AND r.dob != '''' AND r.dob ~ ''^\d{4}-\d{2}-\d{2}' THEN 
                   EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE))
               ELSE NULL 
           END as age_years
       FROM records r
   )
   SELECT 
       l.from_id,
       l.to_id,
       edit_distance(r1.last_name, r2.last_name),
       edit_distance(r1.phone, r2.phone),
       edit_distance(r1.middle_name, r2.middle_name),
       edit_distance(r1.zip, r2.zip),
       edit_distance(r1.city, r2.city),
       CASE 
           WHEN r1.dob IS NULL OR r1.dob = '''' OR r2.dob IS NULL OR r2.dob = '''' OR 
                r1.dob !~ ''^\d{4}-\d{2}-\d{2}' OR r2.dob !~ ''^\d{4}-\d{2}-\d{2}' THEN 100
           ELSE age_difference(r1.dob::DATE, r2.dob::DATE)
       END,
       CASE 
           WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
           WHEN r1.sex != r2.sex THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
           WHEN r1.ssn = r2.ssn THEN 1
           ELSE 0 
       END,
       CASE 
           WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
           WHEN r1.state = r2.state THEN 1
           ELSE 0 
       END,
       edit_distance(r1.address, r2.address),
       CASE 
           WHEN r1.sex IS NULL THEN -1
           WHEN r1.sex = 'M' THEN 0
           WHEN r1.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r2.sex IS NULL THEN -1
           WHEN r2.sex = 'M' THEN 0
           WHEN r2.sex = 'F' THEN 1
           ELSE -1
       END,
       CASE 
           WHEN r1.age_years IS NULL THEN -1
           WHEN r1.age_years < 18 THEN 0
           WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END,
       CASE 
           WHEN r2.age_years IS NULL THEN -1
           WHEN r2.age_years < 18 THEN 0
           WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
           ELSE 2
       END
   FROM labels l
   JOIN age_data r1 ON l.from_id = r1.id
   JOIN age_data r2 ON l.to_id = r2.id
   ON CONFLICT (from_id, to_id) DO NOTHING;
   
   RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-09 14:31:05,303 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 14:31:05,305 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 14:31:05,326 - __main__ - INFO - Read 2000 records
2025-09-09 14:31:05,326 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 14:31:05,335 - __main__ - INFO - Normalized column: last_name
2025-09-09 14:31:05,338 - __main__ - INFO - Normalized column: middle_name
2025-09-09 14:31:05,343 - __main__ - INFO - Normalized column: address
2025-09-09 14:31:05,353 - __main__ - INFO - Normalized column: city
2025-09-09 14:31:05,361 - __main__ - INFO - Normalized column: state
2025-09-09 14:31:05,368 - __main__ - INFO - Converted DOB to datetime
2025-09-09 14:31:05,368 - __main__ - INFO - Cleaned SSN column
2025-09-09 14:31:05,370 - __main__ - INFO - Removed 0 placeholder records
2025-09-09 14:31:05,370 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 14:31:05,771 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 14:31:05,771 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 14:31:05,785 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 14:31:05,785 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 14:31:05,785 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 14:31:07,861 - __main__ - INFO - Cleaned up existing tables
2025-09-09 14:31:07,861 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 14:31:07,861 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 14:31:07,861 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 14:32:43,846 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 14:33:13,734 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 14:33:13,736 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 14:33:13,784 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 14:33:13,784 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 14:33:14,703 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 14:33:14,784 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 14:33:47,062 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 14:33:47,063 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 14:45:35,134 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 14:45:35,134 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 14:45:35,134 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 14:45:35,135 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 14:45:35,157 - __main__ - INFO - Read 2000 records
2025-09-09 14:45:35,158 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 14:45:35,165 - __main__ - INFO - Normalized column: last_name
2025-09-09 14:45:35,168 - __main__ - INFO - Normalized column: middle_name
2025-09-09 14:45:35,171 - __main__ - INFO - Normalized column: address
2025-09-09 14:45:35,174 - __main__ - INFO - Normalized column: city
2025-09-09 14:45:35,177 - __main__ - INFO - Normalized column: state
2025-09-09 14:45:35,180 - __main__ - INFO - Converted DOB to datetime
2025-09-09 14:45:35,180 - __main__ - INFO - Cleaned SSN column
2025-09-09 14:45:35,182 - __main__ - INFO - Removed 0 placeholder records
2025-09-09 14:45:35,182 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 14:45:35,553 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 14:45:35,554 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 14:45:35,567 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 14:45:35,567 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 14:45:35,567 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 14:45:35,719 - __main__ - INFO - Cleaned up existing tables
2025-09-09 14:45:35,719 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 14:45:35,719 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 14:45:35,720 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 14:47:09,673 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 14:47:39,658 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 14:47:39,660 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 14:47:39,708 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 14:47:39,708 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 14:47:40,642 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 14:47:40,730 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 14:48:25,006 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 14:48:25,012 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:27:19,991 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:27:19,991 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:27:19,992 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:27:19,993 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:27:20,023 - __main__ - INFO - Read 2000 records
2025-09-09 15:27:20,023 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:27:20,030 - __main__ - INFO - Normalized last_name column
2025-09-09 15:27:20,031 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:27:20,032 - __main__ - INFO - Normalized sex column
2025-09-09 15:27:20,033 - __main__ - INFO - Normalized address column
2025-09-09 15:27:20,034 - __main__ - INFO - Normalized city column
2025-09-09 15:27:20,035 - __main__ - INFO - Normalized state column
2025-09-09 15:27:20,036 - __main__ - INFO - Normalized ssn column
2025-09-09 15:27:20,037 - __main__ - INFO - Normalized phone column
2025-09-09 15:27:20,037 - __main__ - INFO - Normalized zip column
2025-09-09 15:27:20,041 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:27:20,042 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:27:20,213 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:27:20,214 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:27:20,222 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:27:20,222 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:27:20,222 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:27:20,242 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:27:20,242 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-09 15:27:20,242 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-09 15:27:20,242 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-09 15:27:21,536 - __main__ - INFO - Merging blocking tables...
2025-09-09 15:27:21,683 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-09 15:27:21,683 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-09 15:27:23,004 - __main__ - INFO - Merging comparison results...
2025-09-09 15:27:23,038 - __main__ - INFO - Merged 984 unique record pairs
2025-09-09 15:27:23,038 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:27:23,039 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-09 15:27:23,039 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-09 15:27:25,194 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:27:25,196 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-09 15:27:25,265 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-09 15:27:25,265 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:27:36,638 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:27:36,639 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:27:36,639 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:27:36,642 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:27:36,657 - __main__ - INFO - Read 2000 records
2025-09-09 15:27:36,657 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:27:36,660 - __main__ - INFO - Normalized last_name column
2025-09-09 15:27:36,661 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:27:36,662 - __main__ - INFO - Normalized sex column
2025-09-09 15:27:36,663 - __main__ - INFO - Normalized address column
2025-09-09 15:27:36,664 - __main__ - INFO - Normalized city column
2025-09-09 15:27:36,665 - __main__ - INFO - Normalized state column
2025-09-09 15:27:36,666 - __main__ - INFO - Normalized ssn column
2025-09-09 15:27:36,667 - __main__ - INFO - Normalized phone column
2025-09-09 15:27:36,667 - __main__ - INFO - Normalized zip column
2025-09-09 15:27:36,669 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:27:36,670 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:27:36,909 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:27:36,910 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:27:36,922 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:27:36,922 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:27:36,922 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:27:37,053 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:27:37,053 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 15:27:37,053 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 15:27:37,053 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 15:29:56,216 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 15:30:28,163 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 15:30:28,228 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:30:28,277 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 15:30:28,277 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 15:30:29,134 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:30:29,220 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 15:31:06,119 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 15:31:06,120 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:33:25,050 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:33:25,050 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:33:25,050 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:33:25,051 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:33:25,070 - __main__ - INFO - Read 2000 records
2025-09-09 15:33:25,070 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:33:25,074 - __main__ - INFO - Normalized last_name column
2025-09-09 15:33:25,075 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:33:25,076 - __main__ - INFO - Normalized sex column
2025-09-09 15:33:25,077 - __main__ - INFO - Normalized address column
2025-09-09 15:33:25,078 - __main__ - INFO - Normalized city column
2025-09-09 15:33:25,079 - __main__ - INFO - Normalized state column
2025-09-09 15:33:25,080 - __main__ - INFO - Normalized ssn column
2025-09-09 15:33:25,081 - __main__ - INFO - Normalized phone column
2025-09-09 15:33:25,081 - __main__ - INFO - Normalized zip column
2025-09-09 15:33:25,085 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:33:25,088 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:33:25,369 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:33:25,369 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:33:25,392 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:33:25,392 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:33:25,393 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:33:27,892 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:33:27,893 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 15:33:27,893 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 15:33:27,893 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 15:35:42,757 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 15:36:18,736 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 15:36:18,738 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:36:18,785 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 15:36:18,785 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 15:36:19,621 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:36:19,708 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 15:36:58,136 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 15:36:58,137 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:39:17,097 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:39:17,097 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:39:17,097 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:39:17,098 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:39:17,123 - __main__ - INFO - Read 2000 records
2025-09-09 15:39:17,123 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:39:17,127 - __main__ - INFO - Normalized last_name column
2025-09-09 15:39:17,128 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:39:17,129 - __main__ - INFO - Normalized sex column
2025-09-09 15:39:17,130 - __main__ - INFO - Normalized address column
2025-09-09 15:39:17,131 - __main__ - INFO - Normalized city column
2025-09-09 15:39:17,132 - __main__ - INFO - Normalized state column
2025-09-09 15:39:17,133 - __main__ - INFO - Normalized ssn column
2025-09-09 15:39:17,134 - __main__ - INFO - Normalized phone column
2025-09-09 15:39:17,134 - __main__ - INFO - Normalized zip column
2025-09-09 15:39:17,141 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:39:17,144 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:39:17,456 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:39:17,456 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:39:17,467 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:39:17,467 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:39:17,467 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:39:20,132 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:39:20,132 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 15:39:20,132 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 15:39:20,132 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 15:41:44,665 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 15:42:22,176 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 15:42:22,178 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:42:22,240 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 15:42:22,240 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 15:42:23,265 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:42:23,351 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 15:43:07,030 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 15:43:07,034 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:43:25,200 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:43:25,200 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:43:25,200 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:43:25,202 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:43:25,218 - __main__ - INFO - Read 2000 records
2025-09-09 15:43:25,218 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:43:25,220 - __main__ - INFO - Normalized last_name column
2025-09-09 15:43:25,222 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:43:25,222 - __main__ - INFO - Normalized sex column
2025-09-09 15:43:25,224 - __main__ - INFO - Normalized address column
2025-09-09 15:43:25,225 - __main__ - INFO - Normalized city column
2025-09-09 15:43:25,226 - __main__ - INFO - Normalized state column
2025-09-09 15:43:25,226 - __main__ - INFO - Normalized ssn column
2025-09-09 15:43:25,227 - __main__ - INFO - Normalized phone column
2025-09-09 15:43:25,228 - __main__ - INFO - Normalized zip column
2025-09-09 15:43:25,233 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:43:25,236 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:43:25,713 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:43:25,713 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:43:25,723 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:43:25,723 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:43:25,723 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:43:30,379 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:43:30,379 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-09 15:43:30,379 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-09 15:43:30,379 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-09 15:43:31,591 - __main__ - INFO - Merging blocking tables...
2025-09-09 15:43:31,646 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-09 15:43:31,646 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-09 15:43:32,984 - __main__ - INFO - Merging comparison results...
2025-09-09 15:43:33,012 - __main__ - INFO - Merged 984 unique record pairs
2025-09-09 15:43:33,012 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:43:33,013 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-09 15:43:33,013 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-09 15:43:33,720 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:43:33,722 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-09 15:43:33,792 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-09 15:43:33,792 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:55:23,663 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:55:23,663 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:55:23,663 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:55:23,664 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:55:23,686 - __main__ - INFO - Read 2000 records
2025-09-09 15:55:23,686 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:55:23,691 - __main__ - INFO - Normalized last_name column
2025-09-09 15:55:23,692 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:55:23,692 - __main__ - INFO - Normalized sex column
2025-09-09 15:55:23,694 - __main__ - INFO - Normalized address column
2025-09-09 15:55:23,695 - __main__ - INFO - Normalized city column
2025-09-09 15:55:23,696 - __main__ - INFO - Normalized state column
2025-09-09 15:55:23,697 - __main__ - INFO - Normalized ssn column
2025-09-09 15:55:23,697 - __main__ - INFO - Normalized phone column
2025-09-09 15:55:23,698 - __main__ - INFO - Normalized zip column
2025-09-09 15:55:23,704 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:55:23,707 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:55:24,046 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:55:24,046 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:55:24,056 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:55:24,056 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:55:24,056 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:55:27,939 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:55:27,939 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-09 15:55:27,939 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-09 15:55:27,939 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-09 15:55:29,214 - __main__ - INFO - Merging blocking tables...
2025-09-09 15:55:29,275 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-09 15:55:29,275 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-09 15:55:30,512 - __main__ - INFO - Merging comparison results...
2025-09-09 15:55:30,530 - __main__ - INFO - Merged 984 unique record pairs
2025-09-09 15:55:30,530 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:55:30,531 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-09 15:55:30,531 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-09 15:55:31,332 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:55:31,334 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-09 15:55:31,406 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-09 15:55:31,406 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:55:34,347 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:55:34,347 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:55:34,347 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:55:34,348 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:55:34,357 - __main__ - INFO - Read 2000 records
2025-09-09 15:55:34,357 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:55:34,359 - __main__ - INFO - Normalized last_name column
2025-09-09 15:55:34,360 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:55:34,361 - __main__ - INFO - Normalized sex column
2025-09-09 15:55:34,362 - __main__ - INFO - Normalized address column
2025-09-09 15:55:34,363 - __main__ - INFO - Normalized city column
2025-09-09 15:55:34,364 - __main__ - INFO - Normalized state column
2025-09-09 15:55:34,365 - __main__ - INFO - Normalized ssn column
2025-09-09 15:55:34,366 - __main__ - INFO - Normalized phone column
2025-09-09 15:55:34,366 - __main__ - INFO - Normalized zip column
2025-09-09 15:55:34,368 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:55:34,370 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:55:34,485 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:55:34,485 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:55:34,492 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:55:34,492 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:55:34,493 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:55:34,502 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:55:34,502 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-09 15:55:34,502 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-09 15:55:34,502 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-09 15:57:48,422 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-09 15:58:22,068 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-09 15:58:22,069 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:58:22,117 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-09 15:58:22,117 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-09 15:58:22,990 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:58:23,069 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-09 15:58:55,675 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-09 15:58:55,676 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-09 15:59:06,378 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-09 15:59:06,379 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-09 15:59:06,379 - __main__ - INFO - Previous predictions cleaned up
2025-09-09 15:59:06,380 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-09 15:59:06,396 - __main__ - INFO - Read 2000 records
2025-09-09 15:59:06,396 - __main__ - INFO - Starting normalization of 2000 records
2025-09-09 15:59:06,398 - __main__ - INFO - Normalized last_name column
2025-09-09 15:59:06,399 - __main__ - INFO - Normalized middle_name column
2025-09-09 15:59:06,400 - __main__ - INFO - Normalized sex column
2025-09-09 15:59:06,401 - __main__ - INFO - Normalized address column
2025-09-09 15:59:06,402 - __main__ - INFO - Normalized city column
2025-09-09 15:59:06,403 - __main__ - INFO - Normalized state column
2025-09-09 15:59:06,404 - __main__ - INFO - Normalized ssn column
2025-09-09 15:59:06,405 - __main__ - INFO - Normalized phone column
2025-09-09 15:59:06,405 - __main__ - INFO - Normalized zip column
2025-09-09 15:59:06,408 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-09 15:59:06,412 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-09 15:59:06,810 - __main__ - INFO - Loaded 2000 records to database
2025-09-09 15:59:06,810 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-09 15:59:06,822 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-09 15:59:06,822 - __main__ - INFO - Dataset size: 2000 records
2025-09-09 15:59:06,822 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-09 15:59:10,495 - __main__ - INFO - Cleaned up existing tables
2025-09-09 15:59:10,496 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-09 15:59:10,496 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-09 15:59:10,496 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-09 15:59:11,726 - __main__ - INFO - Merging blocking tables...
2025-09-09 15:59:11,783 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-09 15:59:11,783 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-09 15:59:13,010 - __main__ - INFO - Merging comparison results...
2025-09-09 15:59:13,029 - __main__ - INFO - Merged 984 unique record pairs
2025-09-09 15:59:13,030 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-09 15:59:13,030 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-09 15:59:13,030 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-09 15:59:13,621 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-09 15:59:13,623 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-09 15:59:13,695 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-09 15:59:13,695 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-11 09:01:35,415 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-11 09:01:35,425 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-11 09:01:35,425 - __main__ - INFO - Previous predictions cleaned up
2025-09-11 09:01:35,426 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-11 09:01:35,450 - __main__ - INFO - Read 2000 records
2025-09-11 09:01:35,450 - __main__ - INFO - Starting normalization of 2000 records
2025-09-11 09:01:35,455 - __main__ - INFO - Normalized last_name column
2025-09-11 09:01:35,456 - __main__ - INFO - Normalized middle_name column
2025-09-11 09:01:35,457 - __main__ - INFO - Normalized sex column
2025-09-11 09:01:35,458 - __main__ - INFO - Normalized address column
2025-09-11 09:01:35,459 - __main__ - INFO - Normalized city column
2025-09-11 09:01:35,460 - __main__ - INFO - Normalized state column
2025-09-11 09:01:35,461 - __main__ - INFO - Normalized ssn column
2025-09-11 09:01:35,462 - __main__ - INFO - Normalized phone column
2025-09-11 09:01:35,463 - __main__ - INFO - Normalized zip column
2025-09-11 09:01:35,470 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-11 09:01:35,472 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-11 09:01:35,974 - __main__ - INFO - Loaded 2000 records to database
2025-09-11 09:01:35,974 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-11 09:01:35,987 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-11 09:01:35,987 - __main__ - INFO - Dataset size: 2000 records
2025-09-11 09:01:35,987 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-11 09:01:36,010 - __main__ - INFO - Cleaned up existing tables
2025-09-11 09:01:36,010 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-11 09:01:36,010 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-11 09:01:36,010 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-11 09:01:37,319 - __main__ - INFO - Merging blocking tables...
2025-09-11 09:01:37,417 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-11 09:01:37,417 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-11 09:01:38,637 - __main__ - INFO - Merging comparison results...
2025-09-11 09:01:38,665 - __main__ - INFO - Merged 984 unique record pairs
2025-09-11 09:01:38,665 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-11 09:01:38,666 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-11 09:01:38,666 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-11 09:01:40,300 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-11 09:01:40,303 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-11 09:01:40,374 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-11 09:01:40,374 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-11 09:01:44,512 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-11 09:01:44,512 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-11 09:01:44,512 - __main__ - INFO - Previous predictions cleaned up
2025-09-11 09:01:44,513 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-11 09:01:44,521 - __main__ - INFO - Read 2000 records
2025-09-11 09:01:44,521 - __main__ - INFO - Starting normalization of 2000 records
2025-09-11 09:01:44,523 - __main__ - INFO - Normalized last_name column
2025-09-11 09:01:44,524 - __main__ - INFO - Normalized middle_name column
2025-09-11 09:01:44,524 - __main__ - INFO - Normalized sex column
2025-09-11 09:01:44,526 - __main__ - INFO - Normalized address column
2025-09-11 09:01:44,527 - __main__ - INFO - Normalized city column
2025-09-11 09:01:44,528 - __main__ - INFO - Normalized state column
2025-09-11 09:01:44,529 - __main__ - INFO - Normalized ssn column
2025-09-11 09:01:44,529 - __main__ - INFO - Normalized phone column
2025-09-11 09:01:44,530 - __main__ - INFO - Normalized zip column
2025-09-11 09:01:44,532 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-11 09:01:44,533 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-11 09:01:44,645 - __main__ - INFO - Loaded 2000 records to database
2025-09-11 09:01:44,645 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-11 09:01:44,653 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-11 09:01:44,653 - __main__ - INFO - Dataset size: 2000 records
2025-09-11 09:01:44,653 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-11 09:01:44,663 - __main__ - INFO - Cleaned up existing tables
2025-09-11 09:01:44,663 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-11 09:01:44,663 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-11 09:01:44,663 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-11 09:03:00,461 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-11 09:03:35,192 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-11 09:03:35,194 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-11 09:03:35,241 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-11 09:03:35,241 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-11 09:03:36,108 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-11 09:03:36,195 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-11 09:04:14,693 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-11 09:04:14,694 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-11 09:04:35,016 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-11 09:04:35,016 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-11 09:04:35,017 - __main__ - INFO - Previous predictions cleaned up
2025-09-11 09:04:35,018 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-11 09:04:35,035 - __main__ - INFO - Read 2000 records
2025-09-11 09:04:35,035 - __main__ - INFO - Starting normalization of 2000 records
2025-09-11 09:04:35,037 - __main__ - INFO - Normalized last_name column
2025-09-11 09:04:35,038 - __main__ - INFO - Normalized middle_name column
2025-09-11 09:04:35,039 - __main__ - INFO - Normalized sex column
2025-09-11 09:04:35,040 - __main__ - INFO - Normalized address column
2025-09-11 09:04:35,041 - __main__ - INFO - Normalized city column
2025-09-11 09:04:35,042 - __main__ - INFO - Normalized state column
2025-09-11 09:04:35,043 - __main__ - INFO - Normalized ssn column
2025-09-11 09:04:35,043 - __main__ - INFO - Normalized phone column
2025-09-11 09:04:35,044 - __main__ - INFO - Normalized zip column
2025-09-11 09:04:35,048 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-11 09:04:35,051 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-11 09:04:35,362 - __main__ - INFO - Loaded 2000 records to database
2025-09-11 09:04:35,363 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-11 09:04:35,376 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-11 09:04:35,376 - __main__ - INFO - Dataset size: 2000 records
2025-09-11 09:04:35,376 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-11 09:04:38,372 - __main__ - INFO - Cleaned up existing tables
2025-09-11 09:04:38,373 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-11 09:04:38,373 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-11 09:04:38,373 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-11 09:05:54,446 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-11 09:06:28,801 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-11 09:06:28,802 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-11 09:06:28,849 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-11 09:06:28,850 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-11 09:06:29,759 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-11 09:06:29,832 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-11 09:07:08,742 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-11 09:07:08,747 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 08:11:08,036 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 08:11:08,037 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 08:11:08,037 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:11:08,038 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:11:08,062 - __main__ - INFO - Read 2000 records
2025-09-15 08:11:08,062 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:11:08,068 - __main__ - INFO - Normalized last_name column
2025-09-15 08:11:08,069 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:11:08,069 - __main__ - INFO - Normalized sex column
2025-09-15 08:11:08,071 - __main__ - INFO - Normalized address column
2025-09-15 08:11:08,072 - __main__ - INFO - Normalized city column
2025-09-15 08:11:08,073 - __main__ - INFO - Normalized state column
2025-09-15 08:11:08,073 - __main__ - INFO - Normalized ssn column
2025-09-15 08:11:08,074 - __main__ - INFO - Normalized phone column
2025-09-15 08:11:08,075 - __main__ - INFO - Normalized zip column
2025-09-15 08:11:08,081 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:11:08,084 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:11:08,694 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:11:08,694 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:11:08,706 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:11:08,706 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:11:08,706 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:11:08,714 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:11:08,714 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:11:08,714 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:11:08,714 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:11:09,787 - __main__ - ERROR - Exhaustive worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:11:10,002 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:11:10,002 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 392, in _worker_compare_records_exhaustive
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 67, in compare
    _run_parallel_exhaustive_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 268, in _run_parallel_exhaustive_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:12:33,766 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:12:33,767 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:12:33,789 - __main__ - INFO - Read 2000 records
2025-09-15 08:12:33,789 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:12:33,794 - __main__ - INFO - Normalized last_name column
2025-09-15 08:12:33,795 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:12:33,796 - __main__ - INFO - Normalized sex column
2025-09-15 08:12:33,797 - __main__ - INFO - Normalized address column
2025-09-15 08:12:33,798 - __main__ - INFO - Normalized city column
2025-09-15 08:12:33,799 - __main__ - INFO - Normalized state column
2025-09-15 08:12:33,800 - __main__ - INFO - Normalized ssn column
2025-09-15 08:12:33,801 - __main__ - INFO - Normalized phone column
2025-09-15 08:12:33,801 - __main__ - INFO - Normalized zip column
2025-09-15 08:12:33,806 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:12:33,809 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:12:33,964 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:12:33,965 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:12:33,973 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:12:33,973 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:12:33,973 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:12:33,976 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:12:33,976 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:12:33,976 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:12:33,976 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:12:35,173 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:12:35,274 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:12:35,274 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:12:36,303 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:12:36,562 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:12:36,562 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:17:42,303 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:17:42,304 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:17:42,327 - __main__ - INFO - Read 2000 records
2025-09-15 08:17:42,327 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:17:42,332 - __main__ - INFO - Normalized last_name column
2025-09-15 08:17:42,334 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:17:42,334 - __main__ - INFO - Normalized sex column
2025-09-15 08:17:42,335 - __main__ - INFO - Normalized address column
2025-09-15 08:17:42,336 - __main__ - INFO - Normalized city column
2025-09-15 08:17:42,337 - __main__ - INFO - Normalized state column
2025-09-15 08:17:42,338 - __main__ - INFO - Normalized ssn column
2025-09-15 08:17:42,339 - __main__ - INFO - Normalized phone column
2025-09-15 08:17:42,339 - __main__ - INFO - Normalized zip column
2025-09-15 08:17:42,343 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:17:42,346 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:17:42,530 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:17:42,530 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:17:42,538 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:17:42,538 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:17:42,538 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:17:42,553 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:17:42,553 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:17:42,553 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:17:42,553 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:17:43,963 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:17:44,023 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:17:44,023 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:17:45,225 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:17:45,413 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:17:45,414 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:17:59,091 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:17:59,092 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:17:59,100 - __main__ - INFO - Read 2000 records
2025-09-15 08:17:59,100 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:17:59,102 - __main__ - INFO - Normalized last_name column
2025-09-15 08:17:59,103 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:17:59,104 - __main__ - INFO - Normalized sex column
2025-09-15 08:17:59,105 - __main__ - INFO - Normalized address column
2025-09-15 08:17:59,106 - __main__ - INFO - Normalized city column
2025-09-15 08:17:59,107 - __main__ - INFO - Normalized state column
2025-09-15 08:17:59,108 - __main__ - INFO - Normalized ssn column
2025-09-15 08:17:59,108 - __main__ - INFO - Normalized phone column
2025-09-15 08:17:59,109 - __main__ - INFO - Normalized zip column
2025-09-15 08:17:59,111 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:17:59,112 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:17:59,216 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:17:59,216 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:17:59,224 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:17:59,224 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:17:59,224 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:17:59,232 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:17:59,232 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:17:59,233 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:17:59,233 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:18:00,216 - __main__ - ERROR - Exhaustive worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:18:00,442 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:18:00,443 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 392, in _worker_compare_records_exhaustive
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 67, in compare
    _run_parallel_exhaustive_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 268, in _run_parallel_exhaustive_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_0 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '001abf2e-3bf7-4cf4-8c21-fcdce3f86b6e', 'gid_end': '21a2c7a6-f73c-450c-996a-0827d06b012d', 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:21:16,013 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:21:16,015 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:21:16,037 - __main__ - INFO - Read 2000 records
2025-09-15 08:21:16,037 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:21:16,041 - __main__ - INFO - Normalized last_name column
2025-09-15 08:21:16,043 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:21:16,043 - __main__ - INFO - Normalized sex column
2025-09-15 08:21:16,045 - __main__ - INFO - Normalized address column
2025-09-15 08:21:16,046 - __main__ - INFO - Normalized city column
2025-09-15 08:21:16,047 - __main__ - INFO - Normalized state column
2025-09-15 08:21:16,048 - __main__ - INFO - Normalized ssn column
2025-09-15 08:21:16,049 - __main__ - INFO - Normalized phone column
2025-09-15 08:21:16,050 - __main__ - INFO - Normalized zip column
2025-09-15 08:21:16,053 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:21:16,056 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:21:16,231 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:21:16,231 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:21:16,239 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:21:16,239 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:21:16,239 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:21:16,242 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:21:16,242 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:21:16,242 - __main__ - INFO - Using optimized blocking strategy (dataset > 10)
2025-09-15 08:21:16,242 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:21:17,487 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:21:17,552 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:21:17,552 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:21:18,632 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:21:18,840 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:21:18,841 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:28:04,187 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:28:04,189 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:28:04,209 - __main__ - INFO - Read 2000 records
2025-09-15 08:28:04,209 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:28:04,212 - __main__ - INFO - Normalized last_name column
2025-09-15 08:28:04,214 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:28:04,214 - __main__ - INFO - Normalized sex column
2025-09-15 08:28:04,216 - __main__ - INFO - Normalized address column
2025-09-15 08:28:04,217 - __main__ - INFO - Normalized city column
2025-09-15 08:28:04,218 - __main__ - INFO - Normalized state column
2025-09-15 08:28:04,219 - __main__ - INFO - Normalized ssn column
2025-09-15 08:28:04,220 - __main__ - INFO - Normalized phone column
2025-09-15 08:28:04,220 - __main__ - INFO - Normalized zip column
2025-09-15 08:28:04,225 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:28:04,228 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:28:04,431 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:28:04,431 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:28:04,440 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:28:04,440 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:28:04,440 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:28:04,458 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:28:04,458 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:28:04,459 - __main__ - INFO - Using optimized blocking strategy (dataset > 10)
2025-09-15 08:28:04,459 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:28:05,747 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:28:05,802 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:28:05,802 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:28:06,856 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:28:07,087 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:28:07,087 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:28:15,116 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:28:15,117 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:28:15,124 - __main__ - INFO - Read 2000 records
2025-09-15 08:28:15,125 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:28:15,127 - __main__ - INFO - Normalized last_name column
2025-09-15 08:28:15,128 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:28:15,128 - __main__ - INFO - Normalized sex column
2025-09-15 08:28:15,130 - __main__ - INFO - Normalized address column
2025-09-15 08:28:15,131 - __main__ - INFO - Normalized city column
2025-09-15 08:28:15,132 - __main__ - INFO - Normalized state column
2025-09-15 08:28:15,133 - __main__ - INFO - Normalized ssn column
2025-09-15 08:28:15,133 - __main__ - INFO - Normalized phone column
2025-09-15 08:28:15,134 - __main__ - INFO - Normalized zip column
2025-09-15 08:28:15,136 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:28:15,137 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:28:15,247 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:28:15,247 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:28:15,255 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:28:15,255 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:28:15,255 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:28:15,264 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:28:15,264 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:28:15,265 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:28:15,265 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:29:33,186 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 08:30:19,212 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 08:30:19,217 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 08:30:19,273 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 08:30:19,273 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 08:30:21,321 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 08:30:21,428 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 08:31:27,982 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 08:31:27,989 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 08:33:27,491 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 08:33:27,492 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 08:33:27,492 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:33:27,493 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:33:27,515 - __main__ - INFO - Read 2000 records
2025-09-15 08:33:27,515 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:33:27,520 - __main__ - INFO - Normalized last_name column
2025-09-15 08:33:27,522 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:33:27,522 - __main__ - INFO - Normalized sex column
2025-09-15 08:33:27,524 - __main__ - INFO - Normalized address column
2025-09-15 08:33:27,525 - __main__ - INFO - Normalized city column
2025-09-15 08:33:27,526 - __main__ - INFO - Normalized state column
2025-09-15 08:33:27,527 - __main__ - INFO - Normalized ssn column
2025-09-15 08:33:27,528 - __main__ - INFO - Normalized phone column
2025-09-15 08:33:27,529 - __main__ - INFO - Normalized zip column
2025-09-15 08:33:27,533 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:33:27,536 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:33:27,778 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:33:27,778 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:33:27,787 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:33:27,787 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:33:27,787 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:33:27,794 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:33:27,794 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:33:27,794 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:33:27,794 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:33:28,841 - __main__ - ERROR - Exhaustive worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '21a902d8-6f45-4d10-b604-d3fdc1f43426', 'gid_end': '40911f9d-9a2c-40f2-b6af-25b269e32fcd', 'table_suffix': '1', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:33:29,036 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '21a902d8-6f45-4d10-b604-d3fdc1f43426', 'gid_end': '40911f9d-9a2c-40f2-b6af-25b269e32fcd', 'table_suffix': '1', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:33:29,037 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '21a902d8-6f45-4d10-b604-d3fdc1f43426', 'gid_end': '40911f9d-9a2c-40f2-b6af-25b269e32fcd', 'table_suffix': '1', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 392, in _worker_compare_records_exhaustive
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '21a902d8-6f45-4d10-b604-d3fdc1f43426', 'gid_end': '40911f9d-9a2c-40f2-b6af-25b269e32fcd', 'table_suffix': '1', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 67, in compare
    _run_parallel_exhaustive_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 268, in _run_parallel_exhaustive_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 15:                CASE WHEN age_difference(r1.dob, r2.dob) BETW...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
       CREATE UNLOGGED TABLE public.processed_records_worker_1 AS
       WITH age_data AS (
           SELECT 
               r.*,
               EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
           FROM public.records r
       )
       SELECT 
           r1.id as from_id, 
           r2.id as to_id,
           (
               CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
               CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
               CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
               CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
           )::float AS similarity_score,
           edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
           edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
           edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
           edit_distance(r1.zip, r2.zip) as edit_dist_zip,
           edit_distance(r1.city, r2.city) as edit_dist_city,
           age_difference(r1.dob, r2.dob) as age_diff,
           CASE 
               WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
               WHEN r1.sex != r2.sex THEN 1
               ELSE 0 
           END as sex_diff,
           CASE 
               WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
               WHEN r1.ssn = r2.ssn THEN 1
               ELSE 0 
           END as ssn_match,
           CASE 
               WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
               WHEN r1.state = r2.state THEN 1
               ELSE 0 
           END as state_match,
           edit_distance(r1.address, r2.address) as edit_dist_mail_address,
           CASE 
               WHEN r1.sex IS NULL THEN -1
               WHEN r1.sex = 'M' THEN 0
               WHEN r1.sex = 'F' THEN 1
               ELSE -1
           END as record1_sex,
           CASE 
               WHEN r2.sex IS NULL THEN -1
               WHEN r2.sex = 'M' THEN 0
               WHEN r2.sex = 'F' THEN 1
               ELSE -1
           END as record2_sex,
           CASE 
               WHEN r1.age_years IS NULL THEN -1
               WHEN r1.age_years < 18 THEN 0
               WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record1_agecategory,
           CASE 
               WHEN r2.age_years IS NULL THEN -1
               WHEN r2.age_years < 18 THEN 0
               WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
               ELSE 2
           END as record2_agecategory
       FROM age_data r1
       JOIN age_data r2 ON r1.id < r2.id
       WHERE r1.id BETWEEN $1 AND $2
   
CONTEXT:  PL/pgSQL function compare_records_exhaustive_parallel(text,text,text,text,text) line 18 at EXECUTE

[SQL: SELECT compare_records_exhaustive_parallel(%(gid_start)s, %(gid_end)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'gid_start': '21a902d8-6f45-4d10-b604-d3fdc1f43426', 'gid_end': '40911f9d-9a2c-40f2-b6af-25b269e32fcd', 'table_suffix': '1', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:38:07,561 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:38:07,562 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:38:07,585 - __main__ - INFO - Read 2000 records
2025-09-15 08:38:07,585 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:38:07,588 - __main__ - INFO - Normalized last_name column
2025-09-15 08:38:07,590 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:38:07,590 - __main__ - INFO - Normalized sex column
2025-09-15 08:38:07,592 - __main__ - INFO - Normalized address column
2025-09-15 08:38:07,593 - __main__ - INFO - Normalized city column
2025-09-15 08:38:07,594 - __main__ - INFO - Normalized state column
2025-09-15 08:38:07,594 - __main__ - INFO - Normalized ssn column
2025-09-15 08:38:07,595 - __main__ - INFO - Normalized phone column
2025-09-15 08:38:07,596 - __main__ - INFO - Normalized zip column
2025-09-15 08:38:07,600 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:38:07,603 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:38:07,775 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:38:07,775 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:38:07,783 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:38:07,783 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:38:07,783 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:38:07,786 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:38:07,786 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:38:07,786 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:38:07,786 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:39:23,199 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 08:39:54,815 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 08:39:54,819 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 08:39:54,866 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 08:39:54,866 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 08:39:55,776 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 08:39:55,863 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 08:40:26,633 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 08:40:26,634 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 08:42:52,268 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 08:42:52,269 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 08:42:52,269 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:42:52,270 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:42:52,296 - __main__ - INFO - Read 2000 records
2025-09-15 08:42:52,296 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:42:52,300 - __main__ - INFO - Normalized last_name column
2025-09-15 08:42:52,301 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:42:52,302 - __main__ - INFO - Normalized sex column
2025-09-15 08:42:52,303 - __main__ - INFO - Normalized address column
2025-09-15 08:42:52,304 - __main__ - INFO - Normalized city column
2025-09-15 08:42:52,305 - __main__ - INFO - Normalized state column
2025-09-15 08:42:52,306 - __main__ - INFO - Normalized ssn column
2025-09-15 08:42:52,307 - __main__ - INFO - Normalized phone column
2025-09-15 08:42:52,307 - __main__ - INFO - Normalized zip column
2025-09-15 08:42:52,312 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:42:52,315 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:42:52,572 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:42:52,572 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:42:52,580 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:42:52,580 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:42:52,580 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:42:52,587 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:42:52,587 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:42:52,588 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:42:52,588 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:42:53,836 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:42:53,889 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:42:53,889 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:42:54,888 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_G650_GREENE', 'block_end': 'N_J520_JONES', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '2', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:42:55,085 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_G650_GREENE', 'block_end': 'N_J520_JONES', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '2', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:42:55,086 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_G650_GREENE', 'block_end': 'N_J520_JONES', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '2', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_G650_GREENE', 'block_end': 'N_J520_JONES', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '2', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 42:                        CASE WHEN age_difference(r1_dob, r2_d...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_2 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_G650_GREENE', 'block_end': 'N_J520_JONES', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '2', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:45:55,239 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:45:55,241 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:45:55,262 - __main__ - INFO - Read 2000 records
2025-09-15 08:45:55,262 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:45:55,269 - __main__ - INFO - Normalized last_name column
2025-09-15 08:45:55,270 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:45:55,271 - __main__ - INFO - Normalized sex column
2025-09-15 08:45:55,272 - __main__ - INFO - Normalized address column
2025-09-15 08:45:55,273 - __main__ - INFO - Normalized city column
2025-09-15 08:45:55,274 - __main__ - INFO - Normalized state column
2025-09-15 08:45:55,275 - __main__ - INFO - Normalized ssn column
2025-09-15 08:45:55,276 - __main__ - INFO - Normalized phone column
2025-09-15 08:45:55,276 - __main__ - INFO - Normalized zip column
2025-09-15 08:45:55,281 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:45:55,284 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:45:55,472 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:45:55,472 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:45:55,480 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:45:55,480 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:45:55,480 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:45:55,489 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:45:55,489 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:45:55,489 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:45:55,489 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:45:56,747 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:45:56,793 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:45:56,794 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:45:58,117 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_J525_JOHNSO', 'block_end': 'N_M635_MARTIN', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '3', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:45:58,305 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_J525_JOHNSO', 'block_end': 'N_M635_MARTIN', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '3', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:45:58,306 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_J525_JOHNSO', 'block_end': 'N_M635_MARTIN', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '3', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_J525_JOHNSO', 'block_end': 'N_M635_MARTIN', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '3', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_3 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'N_J525_JOHNSO', 'block_end': 'N_M635_MARTIN', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '3', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:48:28,613 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:48:28,615 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:48:28,636 - __main__ - INFO - Read 2000 records
2025-09-15 08:48:28,636 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:48:28,640 - __main__ - INFO - Normalized last_name column
2025-09-15 08:48:28,642 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:48:28,642 - __main__ - INFO - Normalized sex column
2025-09-15 08:48:28,644 - __main__ - INFO - Normalized address column
2025-09-15 08:48:28,645 - __main__ - INFO - Normalized city column
2025-09-15 08:48:28,646 - __main__ - INFO - Normalized state column
2025-09-15 08:48:28,646 - __main__ - INFO - Normalized ssn column
2025-09-15 08:48:28,647 - __main__ - INFO - Normalized phone column
2025-09-15 08:48:28,648 - __main__ - INFO - Normalized zip column
2025-09-15 08:48:28,652 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:48:28,655 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:48:28,817 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:48:28,817 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:48:28,826 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:48:28,826 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:48:28,826 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:48:28,835 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:48:28,835 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:48:28,835 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:48:28,835 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:48:30,113 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:48:30,159 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:48:30,159 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:48:31,265 - __main__ - ERROR - Comparison worker failed: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:48:31,492 - __main__ - ERROR - Error in compare function: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:48:31,493 - __main__ - ERROR - Error in main: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedFunction: function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 367, in _worker_compare_records_optimized
    connection.execute(text(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 207, in _run_parallel_optimized_comparison_with_progress
    future.result()
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedFunction) function age_difference(date, date) does not exist
LINE 51:                    age_difference(r1_dob, r2_dob),
                            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  
                INSERT INTO public.processed_records_worker_0 (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob::DATE)) as age_years
                    FROM public.record_blocks rb
                    JOIN public.records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT
                r1_gid, r2_gid,
                   (
                       CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                       CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                       CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                       CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                   )::float,
                   edit_distance(r1_ln, r2_ln),
                   edit_distance(r1_tel, r2_tel),
                   edit_distance(r1_mi, r2_mi),
                   edit_distance(r1_zip, r2_zip),
                   edit_distance(r1_city, r2_city),
                   age_difference(r1_dob, r2_dob),
                   CASE 
                       WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                       WHEN r1_sex != r2_sex THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                       WHEN r1_ssn = r2_ssn THEN 1
                       ELSE 0 
                   END,
                   CASE 
                       WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                       WHEN r1_st = r2_st THEN 1
                       ELSE 0 
                   END,
                   edit_distance(r1_adr, r2_adr),
                   CASE 
                       WHEN r1_sex IS NULL THEN -1
                       WHEN r1_sex = 'M' THEN 0
                       WHEN r1_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r2_sex IS NULL THEN -1
                       WHEN r2_sex = 'M' THEN 0
                       WHEN r2_sex = 'F' THEN 1
                       ELSE -1
                   END,
                   CASE 
                       WHEN r1_age_years IS NULL THEN -1
                       WHEN r1_age_years < 18 THEN 0
                       WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END,
                   CASE 
                       WHEN r2_age_years IS NULL THEN -1
                       WHEN r2_age_years < 18 THEN 0
                       WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                       ELSE 2
                   END
               FROM record_pairs
               WHERE (
                   CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                   CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                                          CASE WHEN age_difference(r1_dob::text, r2_dob::text) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                   CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                   CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
               )::float >= $4
               ON CONFLICT (from_id, to_id) DO NOTHING
           
CONTEXT:  PL/pgSQL function compare_records_optimized_parallel(text,text,integer,integer,integer,double precision,text,text,text) line 59 at EXECUTE

[SQL: SELECT compare_records_optimized_parallel(%(block_start)s, %(block_end)s, %(max_block_size)s, %(window_size)s, %(overlap)s, %(similarity_threshold)s, %(table_suffix)s, %(job_schema)s, %(records_table)s)]
[parameters: {'block_start': 'A_NA_NA', 'block_end': 'N_C462_CLARK', 'max_block_size': 500, 'window_size': 100, 'overlap': 50, 'similarity_threshold': 2.0, 'table_suffix': '0', 'job_schema': 'public', 'records_table': 'records'}]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-15 08:56:57,754 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:56:57,756 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:56:57,775 - __main__ - INFO - Read 2000 records
2025-09-15 08:56:57,775 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:56:57,780 - __main__ - INFO - Normalized last_name column
2025-09-15 08:56:57,781 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:56:57,781 - __main__ - INFO - Normalized sex column
2025-09-15 08:56:57,783 - __main__ - INFO - Normalized address column
2025-09-15 08:56:57,784 - __main__ - INFO - Normalized city column
2025-09-15 08:56:57,785 - __main__ - INFO - Normalized state column
2025-09-15 08:56:57,786 - __main__ - INFO - Normalized ssn column
2025-09-15 08:56:57,786 - __main__ - INFO - Normalized phone column
2025-09-15 08:56:57,787 - __main__ - INFO - Normalized zip column
2025-09-15 08:56:57,791 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:56:57,794 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:56:57,986 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:56:57,986 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:56:57,995 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:56:57,995 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:56:57,995 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:56:57,998 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:56:57,998 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:56:57,998 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:56:57,998 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:56:59,254 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:56:59,306 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:56:59,306 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:57:00,579 - __main__ - INFO - Merging comparison results...
2025-09-15 08:57:00,595 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 08:57:00,595 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 08:57:00,596 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 08:57:00,596 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 08:57:01,418 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 08:57:01,421 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 08:57:01,489 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 08:57:01,489 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 08:57:12,622 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 08:57:12,622 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 08:57:12,622 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:57:12,623 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:57:12,630 - __main__ - INFO - Read 2000 records
2025-09-15 08:57:12,630 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:57:12,632 - __main__ - INFO - Normalized last_name column
2025-09-15 08:57:12,634 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:57:12,634 - __main__ - INFO - Normalized sex column
2025-09-15 08:57:12,635 - __main__ - INFO - Normalized address column
2025-09-15 08:57:12,636 - __main__ - INFO - Normalized city column
2025-09-15 08:57:12,637 - __main__ - INFO - Normalized state column
2025-09-15 08:57:12,638 - __main__ - INFO - Normalized ssn column
2025-09-15 08:57:12,639 - __main__ - INFO - Normalized phone column
2025-09-15 08:57:12,639 - __main__ - INFO - Normalized zip column
2025-09-15 08:57:12,641 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:57:12,643 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:57:12,746 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:57:12,746 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:57:12,754 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:57:12,754 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:57:12,754 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:57:12,761 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:57:12,761 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 08:57:12,761 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 08:57:12,761 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 08:58:28,875 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 08:58:57,196 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 08:58:57,199 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 08:58:57,246 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 08:58:57,246 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 08:58:58,135 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 08:58:58,221 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 08:59:30,349 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 08:59:30,351 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 08:59:55,501 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 08:59:55,501 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 08:59:55,501 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 08:59:55,502 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 08:59:55,523 - __main__ - INFO - Read 2000 records
2025-09-15 08:59:55,523 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 08:59:55,528 - __main__ - INFO - Normalized last_name column
2025-09-15 08:59:55,529 - __main__ - INFO - Normalized middle_name column
2025-09-15 08:59:55,530 - __main__ - INFO - Normalized sex column
2025-09-15 08:59:55,531 - __main__ - INFO - Normalized address column
2025-09-15 08:59:55,532 - __main__ - INFO - Normalized city column
2025-09-15 08:59:55,533 - __main__ - INFO - Normalized state column
2025-09-15 08:59:55,534 - __main__ - INFO - Normalized ssn column
2025-09-15 08:59:55,535 - __main__ - INFO - Normalized phone column
2025-09-15 08:59:55,535 - __main__ - INFO - Normalized zip column
2025-09-15 08:59:55,540 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 08:59:55,543 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 08:59:55,912 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 08:59:55,913 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 08:59:55,926 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 08:59:55,926 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 08:59:55,926 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 08:59:57,222 - __main__ - INFO - Cleaned up existing tables
2025-09-15 08:59:57,222 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 08:59:57,222 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 08:59:57,222 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 08:59:58,516 - __main__ - INFO - Merging blocking tables...
2025-09-15 08:59:58,586 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 08:59:58,586 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 08:59:59,878 - __main__ - INFO - Merging comparison results...
2025-09-15 08:59:59,894 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 08:59:59,894 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 08:59:59,895 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 08:59:59,895 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 09:00:00,706 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:00:00,709 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 09:00:00,777 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 09:00:00,777 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 09:16:47,073 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 09:16:47,073 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 09:16:47,073 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:16:47,074 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:16:47,095 - __main__ - INFO - Read 2000 records
2025-09-15 09:16:47,095 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:16:47,100 - __main__ - INFO - Normalized last_name column
2025-09-15 09:16:47,101 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:16:47,102 - __main__ - INFO - Normalized sex column
2025-09-15 09:16:47,104 - __main__ - INFO - Normalized address column
2025-09-15 09:16:47,105 - __main__ - INFO - Normalized city column
2025-09-15 09:16:47,105 - __main__ - INFO - Normalized state column
2025-09-15 09:16:47,106 - __main__ - INFO - Normalized ssn column
2025-09-15 09:16:47,107 - __main__ - INFO - Normalized phone column
2025-09-15 09:16:47,108 - __main__ - INFO - Normalized zip column
2025-09-15 09:16:47,112 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:16:47,115 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:16:47,417 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:16:47,417 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:16:47,427 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:16:47,427 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:16:47,427 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:16:47,433 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:16:47,444 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:16:47,444 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:16:47,444 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:16:48,670 - __main__ - ERROR - Worker failed: 'Connection' object has no attribute 'commit'
2025-09-15 09:16:48,930 - __main__ - ERROR - Error in compare function: 'Connection' object has no attribute 'commit'
2025-09-15 09:16:48,931 - __main__ - ERROR - Error in main: 'Connection' object has no attribute 'commit'
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 425, in _worker_create_blocking_keys
    connection.commit()  # Explicitly commit
    ^^^^^^^^^^^^^^^^^
AttributeError: 'Connection' object has no attribute 'commit'
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 153, in _run_parallel_optimized_comparison_with_progress
    future.result()  # This will raise an exception if the worker failed
    ^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
AttributeError: 'Connection' object has no attribute 'commit'
2025-09-15 09:19:33,123 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:19:33,125 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:19:33,146 - __main__ - INFO - Read 2000 records
2025-09-15 09:19:33,146 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:19:33,151 - __main__ - INFO - Normalized last_name column
2025-09-15 09:19:33,153 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:19:33,153 - __main__ - INFO - Normalized sex column
2025-09-15 09:19:33,155 - __main__ - INFO - Normalized address column
2025-09-15 09:19:33,156 - __main__ - INFO - Normalized city column
2025-09-15 09:19:33,157 - __main__ - INFO - Normalized state column
2025-09-15 09:19:33,157 - __main__ - INFO - Normalized ssn column
2025-09-15 09:19:33,158 - __main__ - INFO - Normalized phone column
2025-09-15 09:19:33,159 - __main__ - INFO - Normalized zip column
2025-09-15 09:19:33,163 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:19:33,166 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:19:33,436 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:19:33,436 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:19:33,446 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:19:33,446 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:19:33,446 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:19:33,450 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:19:33,450 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:19:33,450 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:19:33,450 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:19:34,804 - __main__ - ERROR - Worker failed: 'Connection' object has no attribute 'commit'
2025-09-15 09:19:35,046 - __main__ - ERROR - Error in compare function: 'Connection' object has no attribute 'commit'
2025-09-15 09:19:35,047 - __main__ - ERROR - Error in main: 'Connection' object has no attribute 'commit'
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 425, in _worker_create_blocking_keys
    connection.commit()  # Explicitly commit
    ^^^^^^^^^^^^^^^^^
AttributeError: 'Connection' object has no attribute 'commit'
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 153, in _run_parallel_optimized_comparison_with_progress
    future.result()  # This will raise an exception if the worker failed
    ^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
AttributeError: 'Connection' object has no attribute 'commit'
2025-09-15 09:21:52,680 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:21:52,682 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:21:52,704 - __main__ - INFO - Read 2000 records
2025-09-15 09:21:52,704 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:21:52,709 - __main__ - INFO - Normalized last_name column
2025-09-15 09:21:52,710 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:21:52,711 - __main__ - INFO - Normalized sex column
2025-09-15 09:21:52,712 - __main__ - INFO - Normalized address column
2025-09-15 09:21:52,713 - __main__ - INFO - Normalized city column
2025-09-15 09:21:52,714 - __main__ - INFO - Normalized state column
2025-09-15 09:21:52,715 - __main__ - INFO - Normalized ssn column
2025-09-15 09:21:52,716 - __main__ - INFO - Normalized phone column
2025-09-15 09:21:52,716 - __main__ - INFO - Normalized zip column
2025-09-15 09:21:52,721 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:21:52,724 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:21:52,887 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:21:52,887 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:21:52,895 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:21:52,895 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:21:52,895 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:21:52,897 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:21:52,897 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:21:52,898 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:21:52,898 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:21:53,951 - __main__ - ERROR - Worker failed: 'Connection' object has no attribute 'commit'
2025-09-15 09:21:54,147 - __main__ - ERROR - Error in compare function: 'Connection' object has no attribute 'commit'
2025-09-15 09:21:54,148 - __main__ - ERROR - Error in main: 'Connection' object has no attribute 'commit'
concurrent.futures.process._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/process.py", line 256, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 425, in _worker_create_blocking_keys
    connection.commit()  # Explicitly commit
    ^^^^^^^^^^^^^^^^^
AttributeError: 'Connection' object has no attribute 'commit'
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 159, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 59, in compare
    _run_parallel_optimized_comparison_with_progress(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 153, in _run_parallel_optimized_comparison_with_progress
    future.result()  # This will raise an exception if the worker failed
    ^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/concurrent/futures/_base.py", line 401, in __get_result
    raise self._exception
AttributeError: 'Connection' object has no attribute 'commit'
2025-09-15 09:22:19,107 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:22:19,108 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:22:19,130 - __main__ - INFO - Read 2000 records
2025-09-15 09:22:19,130 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:22:19,133 - __main__ - INFO - Normalized last_name column
2025-09-15 09:22:19,135 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:22:19,135 - __main__ - INFO - Normalized sex column
2025-09-15 09:22:19,137 - __main__ - INFO - Normalized address column
2025-09-15 09:22:19,138 - __main__ - INFO - Normalized city column
2025-09-15 09:22:19,139 - __main__ - INFO - Normalized state column
2025-09-15 09:22:19,139 - __main__ - INFO - Normalized ssn column
2025-09-15 09:22:19,140 - __main__ - INFO - Normalized phone column
2025-09-15 09:22:19,141 - __main__ - INFO - Normalized zip column
2025-09-15 09:22:19,145 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:22:19,147 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:22:19,310 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:22:19,310 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:22:19,318 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:22:19,318 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:22:19,318 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:22:19,321 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:22:19,321 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:22:19,321 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:22:19,321 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:22:20,617 - __main__ - INFO - Merging blocking tables...
2025-09-15 09:22:20,673 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 09:22:20,673 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 09:22:22,075 - __main__ - INFO - Merging comparison results...
2025-09-15 09:22:22,113 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 09:22:22,113 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 09:22:22,114 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 09:22:22,114 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 09:22:22,917 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:22:22,920 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 09:22:22,989 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 09:22:22,989 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 09:23:44,539 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 09:23:44,539 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 09:23:44,539 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:23:44,540 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:23:44,562 - __main__ - INFO - Read 2000 records
2025-09-15 09:23:44,562 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:23:44,566 - __main__ - INFO - Normalized last_name column
2025-09-15 09:23:44,568 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:23:44,569 - __main__ - INFO - Normalized sex column
2025-09-15 09:23:44,570 - __main__ - INFO - Normalized address column
2025-09-15 09:23:44,571 - __main__ - INFO - Normalized city column
2025-09-15 09:23:44,572 - __main__ - INFO - Normalized state column
2025-09-15 09:23:44,573 - __main__ - INFO - Normalized ssn column
2025-09-15 09:23:44,573 - __main__ - INFO - Normalized phone column
2025-09-15 09:23:44,574 - __main__ - INFO - Normalized zip column
2025-09-15 09:23:44,578 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:23:44,580 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:23:44,766 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:23:44,767 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:23:44,774 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:23:44,775 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:23:44,775 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:23:44,789 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:23:44,790 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:23:44,790 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:23:44,790 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:23:46,027 - __main__ - INFO - Merging blocking tables...
2025-09-15 09:23:46,085 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 09:23:46,085 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 09:23:47,355 - __main__ - INFO - Merging comparison results...
2025-09-15 09:23:47,378 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 09:23:47,378 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 09:23:47,378 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 09:23:47,379 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 09:23:48,126 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:23:48,128 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 09:23:48,202 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 09:23:48,203 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 09:27:09,605 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 09:27:09,605 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 09:27:09,606 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:27:09,607 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:27:09,630 - __main__ - INFO - Read 2000 records
2025-09-15 09:27:09,630 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:27:09,635 - __main__ - INFO - Normalized last_name column
2025-09-15 09:27:09,637 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:27:09,637 - __main__ - INFO - Normalized sex column
2025-09-15 09:27:09,639 - __main__ - INFO - Normalized address column
2025-09-15 09:27:09,640 - __main__ - INFO - Normalized city column
2025-09-15 09:27:09,641 - __main__ - INFO - Normalized state column
2025-09-15 09:27:09,641 - __main__ - INFO - Normalized ssn column
2025-09-15 09:27:09,642 - __main__ - INFO - Normalized phone column
2025-09-15 09:27:09,642 - __main__ - INFO - Normalized zip column
2025-09-15 09:27:09,646 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:27:09,649 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:27:09,920 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:27:09,920 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:27:09,929 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:27:09,929 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:27:09,929 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:27:09,933 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:27:09,933 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 09:27:09,933 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 09:27:09,933 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 09:28:33,359 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 09:29:14,439 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 09:29:14,442 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 09:29:14,496 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 09:29:14,496 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 09:29:18,467 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:29:18,631 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 09:29:56,499 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 09:29:56,504 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 09:46:49,491 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 09:46:49,492 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 09:46:49,492 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:46:49,494 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:46:49,516 - __main__ - INFO - Read 2000 records
2025-09-15 09:46:49,516 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:46:49,519 - __main__ - INFO - Normalized last_name column
2025-09-15 09:46:49,521 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:46:49,521 - __main__ - INFO - Normalized sex column
2025-09-15 09:46:49,522 - __main__ - INFO - Normalized address column
2025-09-15 09:46:49,523 - __main__ - INFO - Normalized city column
2025-09-15 09:46:49,525 - __main__ - INFO - Normalized state column
2025-09-15 09:46:49,526 - __main__ - INFO - Normalized ssn column
2025-09-15 09:46:49,526 - __main__ - INFO - Normalized phone column
2025-09-15 09:46:49,527 - __main__ - INFO - Normalized zip column
2025-09-15 09:46:49,531 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:46:49,534 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:46:49,843 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:46:49,843 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:46:49,853 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:46:49,853 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:46:49,853 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:46:49,861 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:46:49,861 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 09:46:49,861 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 09:46:49,861 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 09:46:51,172 - __main__ - INFO - Merging blocking tables...
2025-09-15 09:46:51,235 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 09:46:51,235 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 09:46:52,531 - __main__ - INFO - Merging comparison results...
2025-09-15 09:46:52,556 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 09:46:52,556 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 09:46:52,557 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 09:46:52,557 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 09:46:53,376 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:46:53,379 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 09:46:53,448 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 09:46:53,448 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 09:47:56,743 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 09:47:56,743 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 09:47:56,743 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 09:47:56,745 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 09:47:56,766 - __main__ - INFO - Read 2000 records
2025-09-15 09:47:56,766 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 09:47:56,770 - __main__ - INFO - Normalized last_name column
2025-09-15 09:47:56,772 - __main__ - INFO - Normalized middle_name column
2025-09-15 09:47:56,772 - __main__ - INFO - Normalized sex column
2025-09-15 09:47:56,774 - __main__ - INFO - Normalized address column
2025-09-15 09:47:56,775 - __main__ - INFO - Normalized city column
2025-09-15 09:47:56,776 - __main__ - INFO - Normalized state column
2025-09-15 09:47:56,777 - __main__ - INFO - Normalized ssn column
2025-09-15 09:47:56,777 - __main__ - INFO - Normalized phone column
2025-09-15 09:47:56,778 - __main__ - INFO - Normalized zip column
2025-09-15 09:47:56,782 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 09:47:56,785 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 09:47:57,017 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 09:47:57,017 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 09:47:57,027 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 09:47:57,027 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 09:47:57,027 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 09:47:57,042 - __main__ - INFO - Cleaned up existing tables
2025-09-15 09:47:57,042 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 09:47:57,042 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 09:47:57,042 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 09:49:15,540 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 09:50:18,651 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 09:50:18,655 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 09:50:18,720 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 09:50:18,720 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 09:50:19,748 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 09:50:19,832 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 09:51:40,493 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 09:51:40,500 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 10:18:30,425 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 10:18:30,426 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 10:18:30,426 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 10:18:30,427 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 10:18:30,450 - __main__ - INFO - Read 2000 records
2025-09-15 10:18:30,450 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 10:18:30,455 - __main__ - INFO - Normalized last_name column
2025-09-15 10:18:30,456 - __main__ - INFO - Normalized middle_name column
2025-09-15 10:18:30,457 - __main__ - INFO - Normalized sex column
2025-09-15 10:18:30,459 - __main__ - INFO - Normalized address column
2025-09-15 10:18:30,459 - __main__ - INFO - Normalized city column
2025-09-15 10:18:30,460 - __main__ - INFO - Normalized state column
2025-09-15 10:18:30,461 - __main__ - INFO - Normalized ssn column
2025-09-15 10:18:30,462 - __main__ - INFO - Normalized phone column
2025-09-15 10:18:30,463 - __main__ - INFO - Normalized zip column
2025-09-15 10:18:30,467 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 10:18:30,470 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 10:18:30,737 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 10:18:30,738 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 10:18:30,746 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 10:18:30,746 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 10:18:30,746 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 10:18:31,816 - __main__ - INFO - Cleaned up existing tables
2025-09-15 10:18:31,817 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-15 10:18:31,817 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-15 10:18:31,817 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-15 10:18:33,100 - __main__ - INFO - Merging blocking tables...
2025-09-15 10:18:33,149 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-15 10:18:33,149 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-15 10:18:34,503 - __main__ - INFO - Merging comparison results...
2025-09-15 10:18:34,525 - __main__ - INFO - Merged 984 unique record pairs
2025-09-15 10:18:34,525 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 10:18:34,525 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-15 10:18:34,525 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-15 10:18:35,331 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 10:18:35,334 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-15 10:18:35,402 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-15 10:18:35,402 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-15 10:25:38,519 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-15 10:25:38,519 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-15 10:25:38,519 - __main__ - INFO - Previous predictions cleaned up
2025-09-15 10:25:38,521 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-15 10:25:38,543 - __main__ - INFO - Read 2000 records
2025-09-15 10:25:38,543 - __main__ - INFO - Starting normalization of 2000 records
2025-09-15 10:25:38,548 - __main__ - INFO - Normalized last_name column
2025-09-15 10:25:38,549 - __main__ - INFO - Normalized middle_name column
2025-09-15 10:25:38,550 - __main__ - INFO - Normalized sex column
2025-09-15 10:25:38,552 - __main__ - INFO - Normalized address column
2025-09-15 10:25:38,553 - __main__ - INFO - Normalized city column
2025-09-15 10:25:38,554 - __main__ - INFO - Normalized state column
2025-09-15 10:25:38,554 - __main__ - INFO - Normalized ssn column
2025-09-15 10:25:38,555 - __main__ - INFO - Normalized phone column
2025-09-15 10:25:38,556 - __main__ - INFO - Normalized zip column
2025-09-15 10:25:38,560 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-15 10:25:38,563 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-15 10:25:38,735 - __main__ - INFO - Loaded 2000 records to database
2025-09-15 10:25:38,735 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-15 10:25:38,756 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-15 10:25:38,757 - __main__ - INFO - Dataset size: 2000 records
2025-09-15 10:25:38,757 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-15 10:25:38,771 - __main__ - INFO - Cleaned up existing tables
2025-09-15 10:25:38,771 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-15 10:25:38,771 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-15 10:25:38,771 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-15 10:27:03,540 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-15 10:27:32,463 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-15 10:27:32,466 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-15 10:27:32,513 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-15 10:27:32,513 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-15 10:27:33,479 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-15 10:27:33,576 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-15 10:28:14,688 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-15 10:28:14,689 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-23 11:28:50,610 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-23 11:28:50,610 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-23 11:28:50,610 - __main__ - INFO - Previous predictions cleaned up
2025-09-23 11:28:50,612 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-23 11:28:50,632 - __main__ - INFO - Read 2000 records
2025-09-23 11:28:50,632 - __main__ - INFO - Starting normalization of 2000 records
2025-09-23 11:28:50,637 - __main__ - INFO - Normalized last_name column
2025-09-23 11:28:50,639 - __main__ - INFO - Normalized middle_name column
2025-09-23 11:28:50,639 - __main__ - INFO - Normalized sex column
2025-09-23 11:28:50,641 - __main__ - INFO - Normalized address column
2025-09-23 11:28:50,642 - __main__ - INFO - Normalized city column
2025-09-23 11:28:50,643 - __main__ - INFO - Normalized state column
2025-09-23 11:28:50,644 - __main__ - INFO - Normalized ssn column
2025-09-23 11:28:50,644 - __main__ - INFO - Normalized phone column
2025-09-23 11:28:50,645 - __main__ - INFO - Normalized zip column
2025-09-23 11:28:50,650 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-23 11:28:50,652 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-23 11:28:50,810 - __main__ - INFO - Loaded 2000 records to database
2025-09-23 11:28:50,810 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-23 11:28:50,831 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-23 11:28:50,831 - __main__ - INFO - Dataset size: 2000 records
2025-09-23 11:28:50,831 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-23 11:28:50,835 - __main__ - INFO - Cleaned up existing tables
2025-09-23 11:28:50,835 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-23 11:28:50,835 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-23 11:28:50,835 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-23 11:28:52,101 - __main__ - INFO - Merging blocking tables...
2025-09-23 11:28:52,153 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-23 11:28:52,153 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-23 11:28:53,430 - __main__ - INFO - Merging comparison results...
2025-09-23 11:28:53,446 - __main__ - INFO - Merged 984 unique record pairs
2025-09-23 11:28:53,446 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-23 11:28:53,447 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-23 11:28:53,447 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-23 11:28:56,293 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-23 11:28:56,295 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-23 11:28:56,355 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-23 11:28:56,356 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-23 11:29:15,294 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-23 11:29:15,295 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-23 11:29:15,295 - __main__ - INFO - Previous predictions cleaned up
2025-09-23 11:29:15,296 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-23 11:29:15,317 - __main__ - INFO - Read 2000 records
2025-09-23 11:29:15,317 - __main__ - INFO - Starting normalization of 2000 records
2025-09-23 11:29:15,322 - __main__ - INFO - Normalized last_name column
2025-09-23 11:29:15,324 - __main__ - INFO - Normalized middle_name column
2025-09-23 11:29:15,324 - __main__ - INFO - Normalized sex column
2025-09-23 11:29:15,326 - __main__ - INFO - Normalized address column
2025-09-23 11:29:15,327 - __main__ - INFO - Normalized city column
2025-09-23 11:29:15,327 - __main__ - INFO - Normalized state column
2025-09-23 11:29:15,328 - __main__ - INFO - Normalized ssn column
2025-09-23 11:29:15,329 - __main__ - INFO - Normalized phone column
2025-09-23 11:29:15,330 - __main__ - INFO - Normalized zip column
2025-09-23 11:29:15,333 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-23 11:29:15,336 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-23 11:29:15,501 - __main__ - INFO - Loaded 2000 records to database
2025-09-23 11:29:15,501 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-23 11:29:15,508 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-23 11:29:15,508 - __main__ - INFO - Dataset size: 2000 records
2025-09-23 11:29:15,508 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-23 11:29:15,515 - __main__ - INFO - Cleaned up existing tables
2025-09-23 11:29:15,515 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-23 11:29:15,515 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-23 11:29:15,515 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-23 11:29:16,839 - __main__ - INFO - Merging blocking tables...
2025-09-23 11:29:16,879 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-23 11:29:16,879 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-23 11:29:18,637 - __main__ - INFO - Merging comparison results...
2025-09-23 11:29:18,656 - __main__ - INFO - Merged 984 unique record pairs
2025-09-23 11:29:18,657 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-23 11:29:18,657 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-23 11:29:18,657 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-23 11:29:19,426 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-23 11:29:19,428 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-23 11:29:19,499 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-23 11:29:19,499 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-23 11:30:53,182 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-23 11:30:53,182 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-23 11:30:53,182 - __main__ - INFO - Previous predictions cleaned up
2025-09-23 11:30:53,183 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-23 11:30:53,205 - __main__ - INFO - Read 2000 records
2025-09-23 11:30:53,205 - __main__ - INFO - Starting normalization of 2000 records
2025-09-23 11:30:53,209 - __main__ - INFO - Normalized last_name column
2025-09-23 11:30:53,211 - __main__ - INFO - Normalized middle_name column
2025-09-23 11:30:53,211 - __main__ - INFO - Normalized sex column
2025-09-23 11:30:53,213 - __main__ - INFO - Normalized address column
2025-09-23 11:30:53,214 - __main__ - INFO - Normalized city column
2025-09-23 11:30:53,215 - __main__ - INFO - Normalized state column
2025-09-23 11:30:53,216 - __main__ - INFO - Normalized ssn column
2025-09-23 11:30:53,216 - __main__ - INFO - Normalized phone column
2025-09-23 11:30:53,217 - __main__ - INFO - Normalized zip column
2025-09-23 11:30:53,222 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-23 11:30:53,225 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-23 11:30:53,400 - __main__ - INFO - Loaded 2000 records to database
2025-09-23 11:30:53,400 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-23 11:30:53,409 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-23 11:30:53,409 - __main__ - INFO - Dataset size: 2000 records
2025-09-23 11:30:53,409 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-23 11:30:53,418 - __main__ - INFO - Cleaned up existing tables
2025-09-23 11:30:53,418 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-23 11:30:53,418 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-23 11:30:53,418 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-23 11:30:54,676 - __main__ - INFO - Merging blocking tables...
2025-09-23 11:30:54,725 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-23 11:30:54,725 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-23 11:30:56,031 - __main__ - INFO - Merging comparison results...
2025-09-23 11:30:56,057 - __main__ - INFO - Merged 984 unique record pairs
2025-09-23 11:30:56,057 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-23 11:30:56,057 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-23 11:30:56,057 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-23 11:30:56,817 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-23 11:30:56,819 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-23 11:30:56,890 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-23 11:30:56,890 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
2025-09-23 11:56:28,222 - __main__ - INFO - Removed old file: data/predictions/predictions_partner.csv
2025-09-23 11:56:28,222 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-23 11:56:28,222 - __main__ - INFO - Previous predictions cleaned up
2025-09-23 11:56:28,224 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-23 11:56:28,237 - __main__ - INFO - Read 2000 records
2025-09-23 11:56:28,237 - __main__ - INFO - Starting normalization of 2000 records
2025-09-23 11:56:28,239 - __main__ - INFO - Normalized last_name column
2025-09-23 11:56:28,240 - __main__ - INFO - Normalized middle_name column
2025-09-23 11:56:28,241 - __main__ - INFO - Normalized sex column
2025-09-23 11:56:28,242 - __main__ - INFO - Normalized address column
2025-09-23 11:56:28,243 - __main__ - INFO - Normalized city column
2025-09-23 11:56:28,244 - __main__ - INFO - Normalized state column
2025-09-23 11:56:28,245 - __main__ - INFO - Normalized ssn column
2025-09-23 11:56:28,245 - __main__ - INFO - Normalized phone column
2025-09-23 11:56:28,246 - __main__ - INFO - Normalized zip column
2025-09-23 11:56:28,249 - __main__ - INFO - Normalized dob column (kept as text for CURL compatibility)
2025-09-23 11:56:28,250 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-23 11:56:28,697 - __main__ - INFO - Loaded 2000 records to database
2025-09-23 11:56:28,698 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-23 11:56:28,710 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-23 11:56:28,710 - __main__ - INFO - Dataset size: 2000 records
2025-09-23 11:56:28,710 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-23 11:56:28,747 - __main__ - INFO - Cleaned up existing tables
2025-09-23 11:56:28,747 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-23 11:56:28,747 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-23 11:56:28,747 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-23 11:56:29,952 - __main__ - INFO - Merging blocking tables...
2025-09-23 11:56:30,011 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-23 11:56:30,011 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-23 11:56:31,274 - __main__ - INFO - Merging comparison results...
2025-09-23 11:56:31,298 - __main__ - INFO - Merged 984 unique record pairs
2025-09-23 11:56:31,298 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-23 11:56:31,299 - __main__ - INFO - Progress 100%: Generated 984 record pairs
2025-09-23 11:56:31,299 - __main__ - INFO - Comparison complete: 984 record pairs generated
2025-09-23 11:56:33,304 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-23 11:56:33,307 - __main__ - INFO - Extracting 984 processed records in chunks of 50000
2025-09-23 11:56:33,378 - __main__ - INFO - Generated predictions for 984 record pairs
2025-09-23 11:56:33,378 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
